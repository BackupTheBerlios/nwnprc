*** nw_c2_default3.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_c2_default3.nss	Mon Aug 04 20:18:13 2008
***************
*** 1,27 ****
  //::///////////////////////////////////////////////
  //:: Default: End of Combat Round
  //:: NW_C2_DEFAULT3
! //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Calls the end of combat script every round
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Oct 16, 2001
  //:://////////////////////////////////////////////
  
  #include "NW_I0_GENERIC"
  void main()
  {
      if(GetBehaviorState(NW_FLAG_BEHAVIOR_SPECIAL))
      {
          DetermineSpecialBehavior();
      }
      else if(!GetSpawnInCondition(NW_FLAG_SET_WARNINGS))
      {
         DetermineCombatRound();
      }
      if(GetSpawnInCondition(NW_FLAG_END_COMBAT_ROUND_EVENT))
      {
          SignalEvent(OBJECT_SELF, EventUserDefined(1003));
--- 1,51 ----
  //::///////////////////////////////////////////////
  //:: Default: End of Combat Round
  //:: NW_C2_DEFAULT3
! //:: Copyright (c) 2008 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Calls the end of combat script every round
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Oct 16, 2001
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Feb 16th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////
  
  #include "NW_I0_GENERIC"
+ 
  void main()
  {
+ 
+     if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+         { // set variables on target for mounted combat
+             DeleteLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL");
+             DeleteLocalInt(OBJECT_SELF,"nX3_HP_BEFORE");
+             DeleteLocalInt(OBJECT_SELF,"bX3_ALREADY_MOUNTED_COMBAT");
+             if (GetHasFeat(FEAT_MOUNTED_COMBAT,OBJECT_SELF))
+             { // check for AC increase
+                 int nRoll=d20()+GetSkillRank(SKILL_RIDE);
+                 nRoll=nRoll-10;
+                 if (nRoll>4)
+                 { // ac increase
+                     nRoll=nRoll/5;
+                     ApplyEffectToObject(DURATION_TYPE_TEMPORARY,EffectACIncrease(nRoll),OBJECT_SELF,8.5);
+                 } // ac increase
+             } // check for AC increase
+         } // set variables on target for mounted combat
+ 
      if(GetBehaviorState(NW_FLAG_BEHAVIOR_SPECIAL))
      {
          DetermineSpecialBehavior();
      }
      else if(!GetSpawnInCondition(NW_FLAG_SET_WARNINGS))
      {
         DetermineCombatRound();
      }
      if(GetSpawnInCondition(NW_FLAG_END_COMBAT_ROUND_EVENT))
      {
          SignalEvent(OBJECT_SELF, EventUserDefined(1003));
*** nw_c2_default5.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_c2_default5.nss	Mon Aug 04 20:18:14 2008
***************
*** 3,29 ****
--- 3,40 ----
  //:: NW_C2_DEFAULT5
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      If already fighting then ignore, else determine
      combat round
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Oct 16, 2001
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Jan 4th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////
  
  #include "nw_i0_generic"
  
  void main()
  {
+     if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+         { // set variables on target for mounted combat
+             SetLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL",TRUE);
+             SetLocalInt(OBJECT_SELF,"nX3_HP_BEFORE",GetCurrentHitPoints(OBJECT_SELF));
+         } // set variables on target for mounted combat
+ 
      if(GetFleeToExit()) {
          // Run away!
          ActivateFleeToExit();
      } else if (GetSpawnInCondition(NW_FLAG_SET_WARNINGS)) {
          // We give an attacker one warning before we attack
          // This is not fully implemented yet
          SetSpawnInCondition(NW_FLAG_SET_WARNINGS, FALSE);
  
          //Put a check in to see if this attacker was the last attacker
          //Possibly change the GetNPCWarning function to make the check
      } else {
***************
*** 47,58 ****
  
              //Shout that I was attacked
              SpeakString("NW_I_WAS_ATTACKED", TALKVOLUME_SILENT_TALK);
          }
      }
  
      
      if(GetSpawnInCondition(NW_FLAG_ATTACK_EVENT))
      {
          SignalEvent(OBJECT_SELF, EventUserDefined(EVENT_ATTACKED));
      }
! }
--- 58,69 ----
  
              //Shout that I was attacked
              SpeakString("NW_I_WAS_ATTACKED", TALKVOLUME_SILENT_TALK);
          }
      }
  
  
      if(GetSpawnInCondition(NW_FLAG_ATTACK_EVENT))
      {
          SignalEvent(OBJECT_SELF, EventUserDefined(EVENT_ATTACKED));
      }
! }
*** nw_c2_default6.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_c2_default6.nss	Mon Aug 04 20:18:14 2008
***************
*** 2,34 ****
  //:: NW_C2_DEFAULT6
  //:: Default OnDamaged handler
  /*
      If already fighting then ignore, else determine
      combat round
   */
  //:://////////////////////////////////////////////////
  //:: Copyright (c) 2002 Floodgate Entertainment
  //:: Created By: Naomi Novik
  //:: Created On: 12/22/2002
  //:://////////////////////////////////////////////////
  
  #include "nw_i0_generic"
  
  void main()
  {
      if(GetFleeToExit()) {
          // We're supposed to run away, do nothing
      } else if (GetSpawnInCondition(NW_FLAG_SET_WARNINGS)) {
          // don't do anything?
      } else {
-         object oDamager = GetLastDamager();
          if (!GetIsObjectValid(oDamager)) {
              // don't do anything, we don't have a valid damager
          } else if (!GetIsFighting(OBJECT_SELF)) {
              // If we're not fighting, determine combat round
              if(GetBehaviorState(NW_FLAG_BEHAVIOR_SPECIAL)) {
                  DetermineSpecialBehavior(oDamager);
              } else {
                  if(!GetObjectSeen(oDamager) 
                     && GetArea(OBJECT_SELF) == GetArea(oDamager)) {
                      // We don't see our attacker, go find them
                      ActionMoveToLocation(GetLocation(oDamager), TRUE);
--- 2,66 ----
  //:: NW_C2_DEFAULT6
  //:: Default OnDamaged handler
  /*
      If already fighting then ignore, else determine
      combat round
   */
  //:://////////////////////////////////////////////////
  //:: Copyright (c) 2002 Floodgate Entertainment
  //:: Created By: Naomi Novik
  //:: Created On: 12/22/2002
  //:://////////////////////////////////////////////////
+ //:://////////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Jan 17th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////////
  
  #include "nw_i0_generic"
+ #include "x3_inc_horse"
  
  void main()
  {
+     object oDamager = GetLastDamager();
+     object oMe=OBJECT_SELF;
+     int nHPBefore;
+     if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+     if (GetHasFeat(FEAT_MOUNTED_COMBAT)&&HorseGetIsMounted(OBJECT_SELF))
+     { // see if can negate some damage
+         if (GetLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL"))
+         { // last attack was physical
+             nHPBefore=GetLocalInt(OBJECT_SELF,"nX3_HP_BEFORE");
+             if (!GetLocalInt(OBJECT_SELF,"bX3_ALREADY_MOUNTED_COMBAT"))
+             { // haven't already had a chance to use this for the round
+                 SetLocalInt(OBJECT_SELF,"bX3_ALREADY_MOUNTED_COMBAT",TRUE);
+                 int nAttackRoll=GetBaseAttackBonus(oDamager)+d20();
+                 int nRideCheck=GetSkillRank(SKILL_RIDE,OBJECT_SELF)+d20();
+                 if (nRideCheck>=nAttackRoll&&!GetIsDead(OBJECT_SELF))
+                 { // averted attack
+                     if (GetIsPC(oDamager)) SendMessageToPC(oDamager,GetName(OBJECT_SELF)+GetStringByStrRef(111991));
+                     //if (GetIsPC(OBJECT_SELF)) SendMessageToPCByStrRef(OBJECT_SELF,111992");
+                     if (GetCurrentHitPoints(OBJECT_SELF)<nHPBefore)
+                     { // heal
+                         effect eHeal=EffectHeal(nHPBefore-GetCurrentHitPoints(OBJECT_SELF));
+                         AssignCommand(GetModule(),ApplyEffectToObject(DURATION_TYPE_INSTANT,eHeal,oMe));
+                     } // heal
+                 } // averted attack
+             } // haven't already had a chance to use this for the round
+         } // last attack was physical
+     } // see if can negate some damage
      if(GetFleeToExit()) {
          // We're supposed to run away, do nothing
      } else if (GetSpawnInCondition(NW_FLAG_SET_WARNINGS)) {
          // don't do anything?
      } else {
          if (!GetIsObjectValid(oDamager)) {
              // don't do anything, we don't have a valid damager
          } else if (!GetIsFighting(OBJECT_SELF)) {
              // If we're not fighting, determine combat round
              if(GetBehaviorState(NW_FLAG_BEHAVIOR_SPECIAL)) {
                  DetermineSpecialBehavior(oDamager);
              } else {
                  if(!GetObjectSeen(oDamager)
                     && GetArea(OBJECT_SELF) == GetArea(oDamager)) {
                      // We don't see our attacker, go find them
                      ActionMoveToLocation(GetLocation(oDamager), TRUE);
***************
*** 64,75 ****
                  // Switch targets
                  DetermineCombatRound(oDamager);
              }
          }
      }
  
      // Send the user-defined event signal
      if(GetSpawnInCondition(NW_FLAG_DAMAGED_EVENT))
      {
          SignalEvent(OBJECT_SELF, EventUserDefined(EVENT_DAMAGED));
      }
! }
--- 96,107 ----
                  // Switch targets
                  DetermineCombatRound(oDamager);
              }
          }
      }
  
      // Send the user-defined event signal
      if(GetSpawnInCondition(NW_FLAG_DAMAGED_EVENT))
      {
          SignalEvent(OBJECT_SELF, EventUserDefined(EVENT_DAMAGED));
      }
! }
*** nw_c2_default7.nss	Mon Aug 04 20:20:41 2008  ***prc script modified***
--- nw_c2_default7.nss	Mon Aug 04 20:18:14 2008
***************
*** 3,33 ****
--- 3,42 ----
  /*
    Default OnDeath event handler for NPCs.
  
    Adjusts killer's alignment if appropriate and
    alerts allies to our death.
   */
  //:://////////////////////////////////////////////////
  //:: Copyright (c) 2002 Floodgate Entertainment
  //:: Created By: Naomi Novik
  //:: Created On: 12/22/2002
  //:://////////////////////////////////////////////////
+ //:://////////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: April 1st, 2008
+ //:: Added Support for Dying Wile Mounted
+ //:://///////////////////////////////////////////////
  
  #include "x2_inc_compon"
  #include "x0_i0_spawncond"
+ #include "x3_inc_horse"
  
  void main()
  {
      int nClass = GetLevelByClass(CLASS_TYPE_COMMONER);
      int nAlign = GetAlignmentGoodEvil(OBJECT_SELF);
      object oKiller = GetLastKiller();
+ 
+     if (GetLocalInt(GetModule(),"X3_ENABLE_MOUNT_DB")&&GetIsObjectValid(GetMaster(OBJECT_SELF))) SetLocalInt(GetMaster(OBJECT_SELF),"bX3_STORE_MOUNT_INFO",TRUE);
+ 
  
      // If we're a good/neutral commoner,
      // adjust the killer's alignment evil
      if(nClass > 0 && (nAlign == ALIGNMENT_GOOD || nAlign == ALIGNMENT_NEUTRAL))
      {
          AdjustAlignment(oKiller, ALIGNMENT_EVIL, 5);
      }
  
      // Call to allies to let them know we're dead
      SpeakString("NW_I_AM_DEAD", TALKVOLUME_SILENT_TALK);
  
*** nw_c2_defaultb.nss	Mon Aug 04 20:22:29 2008 ***not a prc script***
--- nw_c2_defaultb.nss	Mon Aug 04 20:18:14 2008
***************
*** 10,42 ****
--- 10,53 ----
      GZ 2003-Oct-02 : - New AoE Behavior AI. Will use
                         Dispel Magic against AOES
                       - Flying Creatures will ignore
                         Grease
  
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Dec 6, 2001
  //:: Last Modified On: 2003-Oct-13
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Jan 4th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////
  
  #include "nw_i0_generic"
  #include "x2_i0_spells"
+ 
  void main()
  {
      object oCaster = GetLastSpellCaster();
  
  
      if(GetLastSpellHarmful())
      {
          SetCommandable(TRUE);
+ 
+         if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+         { // set variables on target for mounted combat
+             DeleteLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL");
+         } // set variables on target for mounted combat
  
          // ------------------------------------------------------------------
          // If I was hurt by someone in my own faction
          // Then clear any hostile feelings I have against them
          // After all, we're all just trying to do our job here
          // if we singe some eyebrow hair, oh well.
          // ------------------------------------------------------------------
          if (GetFactionEqual(oCaster, OBJECT_SELF) == TRUE)
          {
              ClearPersonalReputation(oCaster, OBJECT_SELF);
              ClearAllActions(TRUE);
*** nw_c2_herbivore.nss	Mon Aug 04 20:30:46 2008 ***not a prc script***
--- nw_c2_herbivore.nss	Mon Aug 04 20:18:14 2008
***************
*** 1,29 ****
--- 1,38 ----
  //::///////////////////////////////////////////////
  //:: Default: On Spawn In
  //:: NW_C2_HERBIVORE
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Determines the course of action to be taken
      after having just been spawned in for Herbivores
+ 
+     2007-12-31: Deva Winblood
+     Modified to look for X3_HORSE_OWNER_TAG and if
+     it is defined look for an NPC with that tag
+     nearby or in the module (checks near first).
+     It will make that NPC this horse's master.
+ 
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Dec 21, 2001
  //:://////////////////////////////////////////////
  
  #include "NW_I0_GENERIC"
  #include "NW_O2_CONINCLUDE"
  void main()
  {
+     string sTag;
+     object oNPC;
  // OPTIONAL BEHAVIORS (Comment In or Out to Activate ) ****************************************************************************
       //SetSpawnInCondition(NW_FLAG_SPECIAL_CONVERSATION);
       //SetSpawnInCondition(NW_FLAG_SPECIAL_COMBAT_CONVERSATION);
                  // This causes the creature to say a special greeting in their conversation file
                  // upon Perceiving the player. Attach the [NW_D2_GenCheck.nss] script to the desired
                  // greeting in order to designate it. As the creature is actually saying this to
                  // himself, don't attach any player responses to the greeting.
       //SetSpawnInCondition(NW_FLAG_SHOUT_ATTACK_MY_TARGET);
                  // This will set the listening pattern on the NPC to attack when allies call
       //SetSpawnInCondition(NW_FLAG_STEALTH);
                  // If the NPC has stealth and they are a rogue go into stealth mode
***************
*** 63,82 ****
      On Spawn In script this script is meant to be customized by the end user to allow for unique behaviors.  The user defined
      events user 1000 - 1010
  */
      //SetSpawnInCondition(NW_FLAG_HEARTBEAT_EVENT);        //OPTIONAL BEHAVIOR - Fire User Defined Event 1001
      //SetSpawnInCondition(NW_FLAG_PERCIEVE_EVENT);         //OPTIONAL BEHAVIOR - Fire User Defined Event 1002
      //SetSpawnInCondition(NW_FLAG_ATTACK_EVENT);           //OPTIONAL BEHAVIOR - Fire User Defined Event 1005
      //SetSpawnInCondition(NW_FLAG_DAMAGED_EVENT);          //OPTIONAL BEHAVIOR - Fire User Defined Event 1006
      //SetSpawnInCondition(NW_FLAG_DISTURBED_EVENT);        //OPTIONAL BEHAVIOR - Fire User Defined Event 1008
      //SetSpawnInCondition(NW_FLAG_END_COMBAT_ROUND_EVENT); //OPTIONAL BEHAVIOR - Fire User Defined Event 1003
      //SetSpawnInCondition(NW_FLAG_ON_DIALOGUE_EVENT);      //OPTIONAL BEHAVIOR - Fire User Defined Event 1004
      //SetSpawnInCondition(NW_FLAG_DEATH_EVENT);            //OPTIONAL BEHAVIOR - Fire User Defined Event 1007
! 
  // DEFAULT GENERIC BEHAVIOR (DO NOT TOUCH) *****************************************************************************************
      SetListeningPatterns();    // Goes through and sets up which shouts the NPC will listen to.
      WalkWayPoints();           // Optional Parameter: void WalkWayPoints(int nRun = FALSE, float fPause = 1.0)
                                 // 1. Looks to see if any Way Points in the module have the tag "WP_" + NPC TAG + "_0X", if so walk them
                                 // 2. If the tag of the Way Point is "POST_" + NPC TAG the creature will return this way point after
                                 //    combat.
      GenerateNPCTreasure();     //* Use this to create a small amount of treasure on the creature
  }
--- 72,111 ----
      On Spawn In script this script is meant to be customized by the end user to allow for unique behaviors.  The user defined
      events user 1000 - 1010
  */
      //SetSpawnInCondition(NW_FLAG_HEARTBEAT_EVENT);        //OPTIONAL BEHAVIOR - Fire User Defined Event 1001
      //SetSpawnInCondition(NW_FLAG_PERCIEVE_EVENT);         //OPTIONAL BEHAVIOR - Fire User Defined Event 1002
      //SetSpawnInCondition(NW_FLAG_ATTACK_EVENT);           //OPTIONAL BEHAVIOR - Fire User Defined Event 1005
      //SetSpawnInCondition(NW_FLAG_DAMAGED_EVENT);          //OPTIONAL BEHAVIOR - Fire User Defined Event 1006
      //SetSpawnInCondition(NW_FLAG_DISTURBED_EVENT);        //OPTIONAL BEHAVIOR - Fire User Defined Event 1008
      //SetSpawnInCondition(NW_FLAG_END_COMBAT_ROUND_EVENT); //OPTIONAL BEHAVIOR - Fire User Defined Event 1003
      //SetSpawnInCondition(NW_FLAG_ON_DIALOGUE_EVENT);      //OPTIONAL BEHAVIOR - Fire User Defined Event 1004
      //SetSpawnInCondition(NW_FLAG_DEATH_EVENT);            //OPTIONAL BEHAVIOR - Fire User Defined Event 1007
!     sTag=GetLocalString(OBJECT_SELF,"X3_HORSE_OWNER_TAG");
!     if (GetStringLength(sTag)>0)
!     { // look for master
!         oNPC=GetNearestObjectByTag(sTag);
!         if (GetIsObjectValid(oNPC)&&GetObjectType(oNPC)==OBJECT_TYPE_CREATURE)
!         { // master found
!             AddHenchman(oNPC);
!         } // master found
!         else
!         { // look in module
!             oNPC=GetObjectByTag(sTag);
!             if (GetIsObjectValid(oNPC)&&GetObjectType(oNPC)==OBJECT_TYPE_CREATURE)
!             { // master found
!                 AddHenchman(oNPC);
!             } // master found
!             else
!             { // master does not exist - remove X3_HORSE_OWNER_TAG
!                 DeleteLocalString(OBJECT_SELF,"X3_HORSE_OWNER_TAG");
!             } // master does not exist - remove X3_HORSE_OWNER_TAG
!         } // look in module
!     } // look for master
  // DEFAULT GENERIC BEHAVIOR (DO NOT TOUCH) *****************************************************************************************
      SetListeningPatterns();    // Goes through and sets up which shouts the NPC will listen to.
      WalkWayPoints();           // Optional Parameter: void WalkWayPoints(int nRun = FALSE, float fPause = 1.0)
                                 // 1. Looks to see if any Way Points in the module have the tag "WP_" + NPC TAG + "_0X", if so walk them
                                 // 2. If the tag of the Way Point is "POST_" + NPC TAG the creature will return this way point after
                                 //    combat.
      GenerateNPCTreasure();     //* Use this to create a small amount of treasure on the creature
  }
*** nw_ch_ac3.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_ch_ac3.nss	Mon Aug 04 20:18:14 2008
***************
*** 2,27 ****
--- 2,39 ----
  //:: Associate: End of Combat End
  //:: NW_CH_AC3
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Calls the end of combat script every round
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Oct 16, 2001
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Jan 4th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////
  #include "X0_INC_HENAI"
  #include "X2_inc_spellhook"
+ 
  void main()
  {
+     if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+         { // set variables on target for mounted combat
+             DeleteLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL");
+             DeleteLocalInt(OBJECT_SELF,"nX3_HP_BEFORE");
+             DeleteLocalInt(OBJECT_SELF,"bX3_ALREADY_MOUNTED_COMBAT");
+         } // set variables on target for mounted combat
  
      if(!GetSpawnInCondition(NW_FLAG_SET_WARNINGS))
      {
         HenchmenCombatRound(OBJECT_INVALID);
      }
  
  
      if(GetSpawnInCondition(NW_FLAG_END_COMBAT_ROUND_EVENT))
      {
          SignalEvent(OBJECT_SELF, EventUserDefined(1003));
      }
*** nw_ch_ac5.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_ch_ac5.nss	Mon Aug 04 20:18:14 2008
***************
*** 3,29 ****
--- 3,40 ----
  //:: NW_CH_AC5
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      If already fighting then ignore, else determine
      combat round
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Oct 16, 2001
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Jan 4th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////
  
  #include "X0_INC_HENAI"
  
  void main()
  {
+     if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+         { // set variables on target for mounted combat
+             SetLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL",TRUE);
+             SetLocalInt(OBJECT_SELF,"nX3_HP_BEFORE",GetCurrentHitPoints(OBJECT_SELF));
+         } // set variables on target for mounted combat
+ 
      SpeakString("NW_I_WAS_ATTACKED", TALKVOLUME_SILENT_TALK);
      if(!GetAssociateState(NW_ASC_IS_BUSY))
      {
          SetCommandable(TRUE);
          if(!GetAssociateState(NW_ASC_MODE_STAND_GROUND))
          {
              if(!GetIsObjectValid(GetAttackTarget()) && !GetIsObjectValid(GetAttemptedSpellTarget()))
              {
                  if(GetIsObjectValid(GetLastAttacker()))
                  {
                      if(GetAssociateState(NW_ASC_MODE_DEFEND_MASTER))
*** nw_ch_ac6.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_ch_ac6.nss	Mon Aug 04 20:18:14 2008
***************
*** 3,34 ****
--- 3,67 ----
  //:: NW_CH_AC6
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      If already fighting then ignore, else determine
      combat round
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Nov 19, 2001
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Jan 17th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////
  
  #include "X0_INC_HENAI"
+ #include "x3_inc_horse"
  
  // Determine whether to switch to new attacker
  int SwitchTargets(object oCurTarget, object oNewEnemy);
  
  void main()
  {
      object oAttacker = GetLastDamager();
      object oTarget = GetAttackTarget();
+     object oDamager = oAttacker;
+     object oMe=OBJECT_SELF;
+     int nHPBefore;
+     if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+     if (GetHasFeat(FEAT_MOUNTED_COMBAT)&&HorseGetIsMounted(OBJECT_SELF))
+     { // see if can negate some damage
+         if (GetLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL"))
+         { // last attack was physical
+             nHPBefore=GetLocalInt(OBJECT_SELF,"nX3_HP_BEFORE");
+             if (!GetLocalInt(OBJECT_SELF,"bX3_ALREADY_MOUNTED_COMBAT"))
+             { // haven't already had a chance to use this for the round
+                 SetLocalInt(OBJECT_SELF,"bX3_ALREADY_MOUNTED_COMBAT",TRUE);
+                 int nAttackRoll=GetBaseAttackBonus(oDamager)+d20();
+                 int nRideCheck=GetSkillRank(SKILL_RIDE,OBJECT_SELF)+d20();
+                 if (nRideCheck>=nAttackRoll&&!GetIsDead(OBJECT_SELF))
+                 { // averted attack
+                     if (GetIsPC(oDamager)) SendMessageToPC(oDamager,GetName(OBJECT_SELF)+GetStringByStrRef(111991));
+                     //if (GetIsPC(OBJECT_SELF)) SendMessageToPCByStrRef(OBJECT_SELF,111992);
+                     if (GetCurrentHitPoints(OBJECT_SELF)<nHPBefore)
+                     { // heal
+                         effect eHeal=EffectHeal(nHPBefore-GetCurrentHitPoints(OBJECT_SELF));
+                         AssignCommand(GetModule(),ApplyEffectToObject(DURATION_TYPE_INSTANT,eHeal,oMe));
+                     } // heal
+                 } // averted attack
+             } // haven't already had a chance to use this for the round
+         } // last attack was physical
+     } // see if can negate some damage
  
      // UNINTERRUPTIBLE ACTIONS
      if(GetAssociateState(NW_ASC_IS_BUSY)
         || GetAssociateState(NW_ASC_MODE_STAND_GROUND)
         || GetCurrentAction() == ACTION_FOLLOW) {
          // We're busy, don't do anything
      }
  
      // DEFEND MASTER
      // Priority is to protect our master
      else if(GetAssociateState(NW_ASC_MODE_DEFEND_MASTER)) {
*** nw_ch_ac7.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_ch_ac7.nss	Mon Aug 04 20:18:14 2008
***************
*** 1,34 ****
  //::///////////////////////////////////////////////
  //:: Henchman Death Script
  //::
  //:: NW_CH_AC7.nss
  //::
! //:: Copyright (c) 2001-2003 Bioware Corp.
  //:://////////////////////////////////////////////
  //:: Official Campaign Henchmen Respawn
  //:://////////////////////////////////////////////
  //::
  //:: Modified by:   Brent, April 3 2002
  //::                Removed delay in respawning
  //::                the henchman - caused bugs
  //:
  //::                Georg, Oct 8 2003
  //::                Rewrote teleport to temple routine
  //::                because it was broken by
  //::                some delicate timing issues in XP2
  //:://////////////////////////////////////////////
  
  #include "nw_i0_generic"
  #include "nw_i0_plot"
! 
  
  // -----------------------------------------------------------------------------
  // Georg, 2003-10-08
  // Rewrote that jump part to get rid of the DelayCommand Code that was prone to
  // timing problems. If want to see a really back hack, this function is just that.
  // -----------------------------------------------------------------------------
  void WrapJump(string sTarget)
  {
      if (GetIsDead(OBJECT_SELF))
      {
          // * Resurrect and heal again, just in case
--- 1,39 ----
  //::///////////////////////////////////////////////
  //:: Henchman Death Script
  //::
  //:: NW_CH_AC7.nss
  //::
! //:: Copyright (c) 2001-2008 Bioware Corp.
  //:://////////////////////////////////////////////
  //:: Official Campaign Henchmen Respawn
  //:://////////////////////////////////////////////
  //::
  //:: Modified by:   Brent, April 3 2002
  //::                Removed delay in respawning
  //::                the henchman - caused bugs
  //:
  //::                Georg, Oct 8 2003
  //::                Rewrote teleport to temple routine
  //::                because it was broken by
  //::                some delicate timing issues in XP2
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: April 9th, 2008
+ //:: Added Support for Dying Wile Mounted
+ //:://///////////////////////////////////////////////
  
  #include "nw_i0_generic"
  #include "nw_i0_plot"
! #include "x3_inc_horse"
  
  // -----------------------------------------------------------------------------
  // Georg, 2003-10-08
  // Rewrote that jump part to get rid of the DelayCommand Code that was prone to
  // timing problems. If want to see a really back hack, this function is just that.
  // -----------------------------------------------------------------------------
  void WrapJump(string sTarget)
  {
      if (GetIsDead(OBJECT_SELF))
      {
          // * Resurrect and heal again, just in case
***************
*** 51,81 ****
--- 56,94 ----
      // * Jump to Target
      JumpToObject(GetObjectByTag(sTarget), FALSE);
  
      // * Unset busy state
      ActionDoCommand(SetAssociateState(NW_ASC_IS_BUSY, FALSE));
  
      // * Make self vulnerable
      SetPlotFlag(OBJECT_SELF, FALSE);
  
      // * Set destroyable flag to leave corpse
      DelayCommand(6.0f, SetIsDestroyable(TRUE, TRUE, TRUE));
+ 
+     // * if mounted make sure dismounted
+     if (HorseGetIsMounted(OBJECT_SELF))
+     { // dismount
+         DelayCommand(3.0,AssignCommand(OBJECT_SELF,HorseDismountWrapper()));
+     } // dismount
+ 
  }
  
  // -----------------------------------------------------------------------------
  // Georg, 2003-10-08
  // Changed to run the bad recursive function above.
  // -----------------------------------------------------------------------------
  void BringBack()
  {
      object oSelf = OBJECT_SELF;
+ 
      SetLocalObject(oSelf,"NW_L_FORMERMASTER", GetMaster());
      RemoveEffects(oSelf);
      ApplyEffectToObject(DURATION_TYPE_PERMANENT, EffectResurrection(), OBJECT_SELF);
      ApplyEffectToObject(DURATION_TYPE_PERMANENT, EffectHeal(GetMaxHitPoints(OBJECT_SELF)), OBJECT_SELF);
  
      object oWay = GetObjectByTag("NW_DEATH_TEMPLE");
  
      if (GetIsObjectValid(oWay) == TRUE)
      {
          // * if in Source stone area, respawn at opening to area
          if (GetTag(GetArea(oSelf)) == "M4Q1D2")
***************
*** 85,108 ****
--- 98,127 ----
          else
          {
              DelayCommand(1.0, WrapJump(GetTag(oWay)));
          }
      }
      else
      {
          WriteTimestampedLogEntry("UT: No place to go");
      }
  
  }
+ 
+ 
  void main()
  {
+     SetLocalString(OBJECT_SELF,"sX3_DEATH_SCRIPT","nw_ch_ac7");
+     if (HorseHandleDeath()) return;
+     DeleteLocalString(OBJECT_SELF,"sX3_DEATH_SCRIPT");
+ 
      // * This is used by the advanced henchmen
      // * Let Brent know if it interferes with animal
      // * companions et cetera
      if (GetIsObjectValid(GetMaster()) == TRUE)
      {
          object oMe = OBJECT_SELF;
          if (GetAssociateType(oMe) == ASSOCIATE_TYPE_HENCHMAN
              // * this is to prevent 'double hits' from stopping
              // * the henchmen from moving to the temple of tyr
              // * I.e., henchmen dies 'twice', once after leaving  your party
              || GetLocalInt(oMe, "NW_L_HEN_I_DIED") == TRUE)
*** nw_ch_ac9.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_ch_ac9.nss	Mon Aug 04 20:18:14 2008
***************
*** 1,25 ****
--- 1,36 ----
  //::///////////////////////////////////////////////
  //:: Associate: On Spawn In
  //:: NW_CH_AC9
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
+ /*
+ 
+     2007-12-31: Deva Winblood
+     Modified to look for X3_HORSE_OWNER_TAG and if
+     it is defined look for an NPC with that tag
+     nearby or in the module (checks near first).
+     It will make that NPC this horse's master.
+ 
+ */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Nov 19, 2001
  //:://////////////////////////////////////////////
  
  #include "X0_INC_HENAI"
  
  void main()
  {
+     string sTag;
+     object oNPC;
      SetAssociateListenPatterns();//Sets up the special henchmen listening patterns
  
      bkSetListeningPatterns();      // Goes through and sets up which shouts the NPC will listen to.
  
      SetAssociateState(NW_ASC_POWER_CASTING);
      SetAssociateState(NW_ASC_HEAL_AT_50);
      SetAssociateState(NW_ASC_RETRY_OPEN_LOCKS);
      SetAssociateState(NW_ASC_DISARM_TRAPS);
      SetAssociateState(NW_ASC_MODE_DEFEND_MASTER, FALSE);
      SetAssociateState(NW_ASC_USE_RANGED_WEAPON, FALSE); //User ranged weapons by default if true.
      SetAssociateState(NW_ASC_DISTANCE_2_METERS);
***************
*** 29,51 ****
      int nType = GetAssociateType(OBJECT_SELF);
      switch (nType)
      {
          case ASSOCIATE_TYPE_ANIMALCOMPANION:
          case ASSOCIATE_TYPE_DOMINATED:
          case ASSOCIATE_TYPE_FAMILIAR:
          case ASSOCIATE_TYPE_SUMMONED:
              SetAssociateState(NW_ASC_DISTANCE_4_METERS);
              break;
  
      }
!     
  /*    if (GetAssociate(ASSOCIATE_TYPE_ANIMALCOMPANION, GetMaster()) == OBJECT_SELF  ||
          GetAssociate(ASSOCIATE_TYPE_DOMINATED, GetMaster()) == OBJECT_SELF  ||
          GetAssociate(ASSOCIATE_TYPE_FAMILIAR, GetMaster()) == OBJECT_SELF  ||
          GetAssociate(ASSOCIATE_TYPE_SUMMONED, GetMaster()) == OBJECT_SELF)
      {
              SetAssociateState(NW_ASC_DISTANCE_4_METERS);
      }
  */
      // * Feb 2003: Set official campaign henchmen to have no inventory
      SetLocalInt(OBJECT_SELF, "X0_L_NOTALLOWEDTOHAVEINVENTORY", 10) ;
  
--- 40,82 ----
      int nType = GetAssociateType(OBJECT_SELF);
      switch (nType)
      {
          case ASSOCIATE_TYPE_ANIMALCOMPANION:
          case ASSOCIATE_TYPE_DOMINATED:
          case ASSOCIATE_TYPE_FAMILIAR:
          case ASSOCIATE_TYPE_SUMMONED:
              SetAssociateState(NW_ASC_DISTANCE_4_METERS);
              break;
  
      }
!     sTag=GetLocalString(OBJECT_SELF,"X3_HORSE_OWNER_TAG");
!     if (GetStringLength(sTag)>0)
!     { // look for master
!         oNPC=GetNearestObjectByTag(sTag);
!         if (GetIsObjectValid(oNPC)&&GetObjectType(oNPC)==OBJECT_TYPE_CREATURE)
!         { // master found
!             AddHenchman(oNPC);
!         } // master found
!         else
!         { // look in module
!             oNPC=GetObjectByTag(sTag);
!             if (GetIsObjectValid(oNPC)&&GetObjectType(oNPC)==OBJECT_TYPE_CREATURE)
!             { // master found
!                 AddHenchman(oNPC);
!             } // master found
!             else
!             { // master does not exist - remove X3_HORSE_OWNER_TAG
!                 DeleteLocalString(OBJECT_SELF,"X3_HORSE_OWNER_TAG");
!             } // master does not exist - remove X3_HORSE_OWNER_TAG
!         } // look in module
!     } // look for master
  /*    if (GetAssociate(ASSOCIATE_TYPE_ANIMALCOMPANION, GetMaster()) == OBJECT_SELF  ||
          GetAssociate(ASSOCIATE_TYPE_DOMINATED, GetMaster()) == OBJECT_SELF  ||
          GetAssociate(ASSOCIATE_TYPE_FAMILIAR, GetMaster()) == OBJECT_SELF  ||
          GetAssociate(ASSOCIATE_TYPE_SUMMONED, GetMaster()) == OBJECT_SELF)
      {
              SetAssociateState(NW_ASC_DISTANCE_4_METERS);
      }
  */
      // * Feb 2003: Set official campaign henchmen to have no inventory
      SetLocalInt(OBJECT_SELF, "X0_L_NOTALLOWEDTOHAVEINVENTORY", 10) ;
  
*** nw_ch_acb.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_ch_acb.nss	Mon Aug 04 20:18:14 2008
***************
*** 3,34 ****
--- 3,44 ----
  //:: NW_CH_ACB
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      This determines if the spell just cast at the
      target is harmful or not.
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Dec 6, 2001
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Jan 4th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////
  
  #include "X0_INC_HENAI"
  #include "x2_i0_spells"
  
  void main()
  {
      object oCaster = GetLastSpellCaster();
      if(GetLastSpellHarmful())
      {
          SetCommandable(TRUE);
+ 
+         if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+         { // set variables on target for mounted combat
+             DeleteLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL");
+         } // set variables on target for mounted combat
  
          // * GZ Oct 3, 2003
          // * Really, the engine should handle this, but hey, this world is not perfect...
          // * If I was hurt by my master or the creature hurting me has
          // * the same master
          // * Then clear any hostile feelings I have against them
          // * After all, we're all just trying to do our job here
          // * if we singe some eyebrow hair, oh well.
          object oMyMaster = GetMaster(OBJECT_SELF);
          if ((oMyMaster != OBJECT_INVALID) && (oMyMaster == oCaster || (oMyMaster  == GetMaster(oCaster)))  )
          {
*** nw_g0_tranpconly.nss	Mon Aug 04 20:31:05 2008 ***not a prc script***
--- nw_g0_tranpconly.nss	Mon Aug 04 20:18:14 2008
***************
*** 1,35 ****
  ////////////////////////////////////////////////////////////
  // OnClick/OnAreaTransitionClick  - No monsters!!!
! // NW_G0_Transition.nss
  // Copyright (c) 2001 Bioware Corp.
  ////////////////////////////////////////////////////////////
  //
  ////////////////////////////////////////////////////////////
  
- void main()
- {
-   object oClicker = GetClickingObject();
  
    
-   // * Only PC's or associates of pc's can do this
-   if (GetIsPC(oClicker) || GetIsPC(GetMaster(oClicker)) == TRUE)
-   {
    
        object oTarget = GetTransitionTarget(OBJECT_SELF);
  
        SetAreaTransitionBMP(AREA_TRANSITION_RANDOM);
  
        AssignCommand(oClicker,JumpToObject(oTarget));
!   }
!  /* else
!   This turned out to be unnecessary since GetIsPC returns true
!   if a player controlled, which includes familiars.
!   // * This is an NPC attempting to cross the transition
!   // * Clear all actions on it (to prevent system
!   // * resource eating by a creature trying to cross
!   // * an area transition that it can't
!   {
!     AssignCommand(oClicker, ClearAllActions());
!   }
!   */
  }
--- 1,102 ----
  ////////////////////////////////////////////////////////////
  // OnClick/OnAreaTransitionClick  - No monsters!!!
! // NW_G0_TranPCOnly.nss
  // Copyright (c) 2001 Bioware Corp.
  ////////////////////////////////////////////////////////////
  //
  ////////////////////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: April 12th, 2008
+ //:: Added Support for Keeping mounts out of no mount areas
+ //::////////////////////////////////////////////////////////
  
  
+ #include "x3_inc_horse"
+ #include "x0_inc_henai"
  
  
+ void main()
+ {
+     int bOk=FALSE;
+     object oClicker=GetClickingObject();
+     if (GetIsPC(oClicker)||GetIsPC(GetMaster(oClicker))||GetIsPC(GetMaster(GetMaster(oClicker)))) bOk=TRUE;
+     if (!bOk) return; // abort for non associates
+     // This code runs as it has already determined this is an associate or the associate of an associate
      object oTarget = GetTransitionTarget(OBJECT_SELF);
+     location lPreJump = HORSE_SupportGetMountLocation(oClicker,oClicker,0.0); // location before jump
+     int bAnim=GetLocalInt(OBJECT_SELF,"bDismountFast"); // community requested fast dismount for transitions if variable is not set (use X3_G0_TranPCOnly for animated)
+     int nN=1;
+     object oOb;
+     object oAreaHere=GetArea(oClicker);
+     object oAreaTarget=GetArea(oTarget);
+     object oHitch;
+     int bDelayedJump=FALSE;
+     int bNoMounts=FALSE;
+     float fX3_MOUNT_MULTIPLE=GetLocalFloat(GetArea(oClicker),"fX3_MOUNT_MULTIPLE");
+     float fX3_DISMOUNT_MULTIPLE=GetLocalFloat(GetArea(oClicker),"fX3_DISMOUNT_MULTIPLE");
+     if (GetLocalFloat(oClicker,"fX3_MOUNT_MULTIPLE")>fX3_MOUNT_MULTIPLE) fX3_MOUNT_MULTIPLE=GetLocalFloat(oClicker,"fX3_MOUNT_MULTIPLE");
+     if (fX3_MOUNT_MULTIPLE<=0.0) fX3_MOUNT_MULTIPLE=1.0;
+     if (GetLocalFloat(oClicker,"fX3_DISMOUNT_MULTIPLE")>0.0) fX3_DISMOUNT_MULTIPLE=GetLocalFloat(oClicker,"fX3_DISMOUNT_MULTIPLE");
+     if (fX3_DISMOUNT_MULTIPLE>0.0) fX3_MOUNT_MULTIPLE=fX3_DISMOUNT_MULTIPLE; // use dismount multiple instead of mount multiple
+     float fDelay=0.1*fX3_MOUNT_MULTIPLE;
+     //SendMessageToPC(oClicker,"nw_g0_transition");
+     if (!GetLocalInt(oAreaTarget,"X3_MOUNT_OK_EXCEPTION"))
+     { // check for global restrictions
+         if (GetLocalInt(GetModule(),"X3_MOUNTS_EXTERNAL_ONLY")&&GetIsAreaInterior(oAreaTarget)) bNoMounts=TRUE;
+         else if (GetLocalInt(GetModule(),"X3_MOUNTS_NO_UNDERGROUND")&&!GetIsAreaAboveGround(oAreaTarget)) bNoMounts=TRUE;
+     } // check for global restrictions
+     if (GetLocalInt(oAreaTarget,"X3_NO_MOUNTING")||GetLocalInt(oAreaTarget,"X3_NO_HORSES")||bNoMounts)
+     { // make sure all transitioning are not mounted
+        //SendMessageToPC(oClicker,"nw_g0_transition:No Mounting");
+         if (HorseGetIsMounted(oClicker))
+         { // dismount clicker
+             bDelayedJump=TRUE;
+             AssignCommand(oClicker,HORSE_SupportDismountWrapper(bAnim,TRUE));
+             fDelay=fDelay+0.2*fX3_MOUNT_MULTIPLE;
+         } // dismount clicker
+         oOb=GetAssociate(ASSOCIATE_TYPE_HENCHMAN,oClicker,nN);
+         while(GetIsObjectValid(oOb))
+         { // check each associate to see if mounted
+             if (HorseGetIsMounted(oOb))
+             { // dismount associate
+                 bDelayedJump=TRUE;
+                 DelayCommand(fDelay,AssignCommand(oOb,HORSE_SupportDismountWrapper(bAnim,TRUE)));
+                 fDelay=fDelay+0.2*fX3_MOUNT_MULTIPLE;
+             } // dismount associate
+             nN++;
+             oOb=GetAssociate(ASSOCIATE_TYPE_HENCHMAN,oClicker,nN);
+         } // check each associate to see if mounted
+         if (fDelay>0.1) SendMessageToPCByStrRef(oClicker,111989);
+         if (bDelayedJump)
+         { // some of the party has/have been mounted, so delay the time to hitch
+             fDelay=fDelay+2.0*fX3_MOUNT_MULTIPLE; // non-animated dismount lasts 1.0+1.0=2.0 by default, so wait at least that!
+             if (bAnim) fDelay=fDelay+2.8*fX3_MOUNT_MULTIPLE; // animated dismount lasts (X3_ACTION_DELAY+HORSE_DISMOUNT_DURATION+1.0)*fX3_MOUNT_MULTIPLE=4.8 by default, so wait at least that!
+         } // some of the party has/have been mounted, so delay the time to hitch
+     } // make sure all transitioning are not mounted
+     if (GetLocalInt(oAreaTarget,"X3_NO_HORSES")||bNoMounts)
+     { // make sure no horses/mounts follow the clicker to this area
+         //SendMessageToPC(oClicker,"nw_g0_transition:No Horses");
+         bDelayedJump=TRUE;
+         oHitch=GetNearestObjectByTag("X3_HITCHING_POST",oClicker);
+         DelayCommand(fDelay,HorseHitchHorses(oHitch,oClicker,lPreJump));
+         if (bAnim) fDelay=fDelay+1.8*fX3_MOUNT_MULTIPLE;
+         //fDelay=fDelay+0.5*fX3_MOUNT_MULTIPLE; // delays jump to transition, makes you stay longer before jump
+     } // make sure no horses/mounts follow the clicker to this area
  
+     //SendMessageToPC(oClicker,"nw_g0_transition:Jump  fDelay="+FloatToString(fDelay));
      SetAreaTransitionBMP(AREA_TRANSITION_RANDOM);
  
+     //if (GetArea(oTarget)!=GetArea(oClicker)) DelayCommand(fDelay,AssignCommand(oClicker,ForceJump(oClicker,oTarget,5.0)));
+     //else { DelayCommand(fDelay,AssignCommand(oClicker,ForceJump(oClicker,oTarget,5.0))); }
+     if (bDelayedJump)
+     { // delayed jump
+         DelayCommand(fDelay,AssignCommand(oClicker,ClearAllActions()));
+         //DelayCommand(fDelay+0.05*fX3_MOUNT_MULTIPLE,AssignCommand(oClicker,ActionWait(X3_ACTION_DELAY/2*fX3_MOUNT_MULTIPLE)));
+         DelayCommand(fDelay+0.1*fX3_MOUNT_MULTIPLE,AssignCommand(oClicker,JumpToObject(oTarget)));
+     } // delayed jump
+     else
+     { // quick jump
          AssignCommand(oClicker,JumpToObject(oTarget));
!     } // quick jump
!     DelayCommand(fDelay+4.0*fX3_MOUNT_MULTIPLE,HorseMoveAssociates(oClicker));
  }
*** nw_g0_transition.nss	Mon Aug 04 20:31:08 2008 ***not a prc script***
--- nw_g0_transition.nss	Mon Aug 04 20:18:14 2008
***************
*** 4,24 ****
--- 4,105 ----
  // Copyright (c) 2001 Bioware Corp.
  ////////////////////////////////////////////////////////////
  // Created By: Sydney Tang
  // Created On: 2001-10-26
  // Description: This is the default script that is called
  //              if no OnClick script is specified for an
  //              Area Transition Trigger or
  //              if no OnAreaTransitionClick script is
  //              specified for a Door that has a LinkedTo
  //              Destination Type other than None.
  ////////////////////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Apr 12th, 2008
+ //:: Added Support for Keeping mounts out of no mount areas
+ //::////////////////////////////////////////////////////////
+ 
+ 
+ #include "x3_inc_horse"
+ #include "x0_inc_henai"
+ 
  
  void main()
  {
      object oClicker=GetClickingObject();
      object oTarget=GetTransitionTarget(OBJECT_SELF);
+     location lPreJump=HORSE_SupportGetMountLocation(oClicker,oClicker,0.0); // location before jump
+     int bAnim=GetLocalInt(OBJECT_SELF,"bDismountFast"); // community requested fast dismount for transitions if variable is not set (use X3_G0_Transition for animated)
+     int nN=1;
+     object oOb;
+     object oAreaHere=GetArea(oClicker);
+     object oAreaTarget=GetArea(oTarget);
+     object oHitch;
+     int bDelayedJump=FALSE;
+     int bNoMounts=FALSE;
+     float fX3_MOUNT_MULTIPLE=GetLocalFloat(GetArea(oClicker),"fX3_MOUNT_MULTIPLE");
+     float fX3_DISMOUNT_MULTIPLE=GetLocalFloat(GetArea(oClicker),"fX3_DISMOUNT_MULTIPLE");
+     if (GetLocalFloat(oClicker,"fX3_MOUNT_MULTIPLE")>fX3_MOUNT_MULTIPLE) fX3_MOUNT_MULTIPLE=GetLocalFloat(oClicker,"fX3_MOUNT_MULTIPLE");
+     if (fX3_MOUNT_MULTIPLE<=0.0) fX3_MOUNT_MULTIPLE=1.0;
+     if (GetLocalFloat(oClicker,"fX3_DISMOUNT_MULTIPLE")>0.0) fX3_DISMOUNT_MULTIPLE=GetLocalFloat(oClicker,"fX3_DISMOUNT_MULTIPLE");
+     if (fX3_DISMOUNT_MULTIPLE>0.0) fX3_MOUNT_MULTIPLE=fX3_DISMOUNT_MULTIPLE; // use dismount multiple instead of mount multiple
+     float fDelay=0.1*fX3_MOUNT_MULTIPLE;
+     //SendMessageToPC(oClicker,"nw_g0_transition");
+     if (!GetLocalInt(oAreaTarget,"X3_MOUNT_OK_EXCEPTION"))
+     { // check for global restrictions
+         if (GetLocalInt(GetModule(),"X3_MOUNTS_EXTERNAL_ONLY")&&GetIsAreaInterior(oAreaTarget)) bNoMounts=TRUE;
+         else if (GetLocalInt(GetModule(),"X3_MOUNTS_NO_UNDERGROUND")&&!GetIsAreaAboveGround(oAreaTarget)) bNoMounts=TRUE;
+     } // check for global restrictions
+     if (GetLocalInt(oAreaTarget,"X3_NO_MOUNTING")||GetLocalInt(oAreaTarget,"X3_NO_HORSES")||bNoMounts)
+     { // make sure all transitioning are not mounted
+        //SendMessageToPC(oClicker,"nw_g0_transition:No Mounting");
+         if (HorseGetIsMounted(oClicker))
+         { // dismount clicker
+             bDelayedJump=TRUE;
+             AssignCommand(oClicker,HORSE_SupportDismountWrapper(bAnim,TRUE));
+             fDelay=fDelay+0.2*fX3_MOUNT_MULTIPLE;
+         } // dismount clicker
+         oOb=GetAssociate(ASSOCIATE_TYPE_HENCHMAN,oClicker,nN);
+         while(GetIsObjectValid(oOb))
+         { // check each associate to see if mounted
+             if (HorseGetIsMounted(oOb))
+             { // dismount associate
+                 bDelayedJump=TRUE;
+                 DelayCommand(fDelay,AssignCommand(oOb,HORSE_SupportDismountWrapper(bAnim,TRUE)));
+                 fDelay=fDelay+0.2*fX3_MOUNT_MULTIPLE;
+             } // dismount associate
+             nN++;
+             oOb=GetAssociate(ASSOCIATE_TYPE_HENCHMAN,oClicker,nN);
+         } // check each associate to see if mounted
+         if (fDelay>0.1) SendMessageToPCByStrRef(oClicker,111989);
+         if (bDelayedJump)
+         { // some of the party has/have been mounted, so delay the time to hitch
+             fDelay=fDelay+2.0*fX3_MOUNT_MULTIPLE; // non-animated dismount lasts 1.0+1.0=2.0 by default, so wait at least that!
+             if (bAnim) fDelay=fDelay+2.8*fX3_MOUNT_MULTIPLE; // animated dismount lasts (X3_ACTION_DELAY+HORSE_DISMOUNT_DURATION+1.0)*fX3_MOUNT_MULTIPLE=4.8 by default, so wait at least that!
+         } // some of the party has/have been mounted, so delay the time to hitch
+     } // make sure all transitioning are not mounted
+     if (GetLocalInt(oAreaTarget,"X3_NO_HORSES")||bNoMounts)
+     { // make sure no horses/mounts follow the clicker to this area
+         //SendMessageToPC(oClicker,"nw_g0_transition:No Horses");
+         bDelayedJump=TRUE;
+         oHitch=GetNearestObjectByTag("X3_HITCHING_POST",oClicker);
+         DelayCommand(fDelay,HorseHitchHorses(oHitch,oClicker,lPreJump));
+         if (bAnim) fDelay=fDelay+1.8*fX3_MOUNT_MULTIPLE;
+         //fDelay=fDelay+0.5*fX3_MOUNT_MULTIPLE; // delays jump to transition, makes you stay longer before jump
+     } // make sure no horses/mounts follow the clicker to this area
  
+     //SendMessageToPC(oClicker,"nw_g0_transition:Jump  fDelay="+FloatToString(fDelay));
      SetAreaTransitionBMP(AREA_TRANSITION_RANDOM);
  
+     //if (GetArea(oTarget)!=GetArea(oClicker)) DelayCommand(fDelay,AssignCommand(oClicker,ForceJump(oClicker,oTarget,5.0)));
+     //else { DelayCommand(fDelay,AssignCommand(oClicker,ForceJump(oClicker,oTarget,5.0))); }
+     if (bDelayedJump)
+     { // delayed jump
+         DelayCommand(fDelay,AssignCommand(oClicker,ClearAllActions()));
+         //DelayCommand(fDelay+0.05*fX3_MOUNT_MULTIPLE,AssignCommand(oClicker,ActionWait(X3_ACTION_DELAY/2*fX3_MOUNT_MULTIPLE)));
+         DelayCommand(fDelay+0.1*fX3_MOUNT_MULTIPLE,AssignCommand(oClicker,JumpToObject(oTarget)));
+     } // delayed jump
+     else
+     { // quick jump
          AssignCommand(oClicker,JumpToObject(oTarget));
+     } // quick jump
+     DelayCommand(fDelay+4.0*fX3_MOUNT_MULTIPLE,HorseMoveAssociates(oClicker));
  }
*** nw_o0_death.nss	Mon Aug 04 20:20:41 2008 ***not a prc script***
--- nw_o0_death.nss	Mon Aug 04 20:18:14 2008
***************
*** 1,26 ****
  //::///////////////////////////////////////////////
  //:: Death Script
  //:: NW_O0_DEATH.NSS
! //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      This script handles the default behavior
      that occurs when a player dies.
      
      BK: October 8 2002: Overriden for Expansion
  */
  //:://////////////////////////////////////////////
  //:: Created By: Brent Knowles
  //:: Created On: November 6, 2001
  //:://////////////////////////////////////////////
   /*
  void ClearAllFactionMembers(object oMember, object oPlayer)
  {
  //    AssignCommand(oMember, SpeakString("here"));
      AdjustReputation(oPlayer, oMember, 100);
      SetLocalInt(oPlayer, "NW_G_Playerhasbeenbad", 10); // * Player bad
      object oClear = GetFirstFactionMember(oMember, FALSE);
      while (GetIsObjectValid(oClear) == TRUE)
      {
          ClearPersonalReputation(oPlayer, oClear);
          oClear = GetNextFactionMember(oMember, FALSE);
--- 1,33 ----
  //::///////////////////////////////////////////////
  //:: Death Script
  //:: NW_O0_DEATH.NSS
! //:: Copyright (c) 2008 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      This script handles the default behavior
      that occurs when a player dies.
  
      BK: October 8 2002: Overriden for Expansion
+ 
+     Deva Winblood:  April 21th, 2008: Modified to
+     handle dismounts when PC dies while mounted.
+ 
  */
  //:://////////////////////////////////////////////
  //:: Created By: Brent Knowles
  //:: Created On: November 6, 2001
  //:://////////////////////////////////////////////
+ 
+ #include "x3_inc_horse"
+ 
   /*
  void ClearAllFactionMembers(object oMember, object oPlayer)
  {
  //    AssignCommand(oMember, SpeakString("here"));
      AdjustReputation(oPlayer, oMember, 100);
      SetLocalInt(oPlayer, "NW_G_Playerhasbeenbad", 10); // * Player bad
      object oClear = GetFirstFactionMember(oMember, FALSE);
      while (GetIsObjectValid(oClear) == TRUE)
      {
          ClearPersonalReputation(oPlayer, oClear);
          oClear = GetNextFactionMember(oMember, FALSE);
***************
*** 52,77 ****
                  {
                      //Remove effect if it is negative.
                      RemoveEffect(oPlayer, eBad);
                  }
              eBad = GetNextEffect(oPlayer);
          }
          //Fire cast spell at event for the specified target
          SignalEvent(oPlayer, EventSpellCastAt(OBJECT_SELF, SPELL_RESTORATION, FALSE));
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eVisual, oPlayer);
  }
  
  void main()
  {
- 
      object oPlayer = GetLastPlayerDied();
      // * increment global tracking number of times that I died
      SetLocalInt(oPlayer, "NW_L_PLAYER_DIED", GetLocalInt(oPlayer, "NW_L_PLAYER_DIED") + 1);
      
      // * BK: Automation Control. Autopcs ignore death
      if (GetLocalInt(oPlayer, "NW_L_AUTOMATION") == 10)
      {
          Raise(oPlayer);
          DelayCommand(1.0, ExecuteScript("crawl", OBJECT_SELF));
          return; // Raise and return
      }
  
--- 59,182 ----
                  {
                      //Remove effect if it is negative.
                      RemoveEffect(oPlayer, eBad);
                  }
              eBad = GetNextEffect(oPlayer);
          }
          //Fire cast spell at event for the specified target
          SignalEvent(oPlayer, EventSpellCastAt(OBJECT_SELF, SPELL_RESTORATION, FALSE));
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eVisual, oPlayer);
  }
  
+ 
+ ///////////////////////////////////////////////////////////////[ MAIN ]/////////
  void main()
  {
      object oPlayer = GetLastPlayerDied();
+     object oHorse;
+     object oInventory;
+     string sID;
+     int nC;
+     string sT;
+     string sR;
+     int nCH;
+     int nST;
+     object oItem;
+     effect eEffect;
+     string sDB="X3SADDLEBAG"+GetTag(GetModule());
+     if (GetStringLength(GetLocalString(GetModule(),"X3_SADDLEBAG_DATABASE"))>0) sDB=GetLocalString(GetModule(),"X3_SADDLEBAG_DATABASE");
+     if (HorseGetIsMounted(oPlayer))
+     { // Dismount and then die
+         //SetCommandable(FALSE,oPlayer);
+         //ApplyEffectToObject(DURATION_TYPE_INSTANT,EffectResurrection(),oPlayer);
+         DelayCommand(0.3,HORSE_SupportResetUnmountedAppearance(oPlayer));
+         DelayCommand(3.0,HORSE_SupportCleanVariables(oPlayer));
+         DelayCommand(1.0,HORSE_SupportRemoveACBonus(oPlayer));
+         DelayCommand(1.0,HORSE_SupportRemoveHPBonus(oPlayer));
+         DelayCommand(1.1,HORSE_SupportRemoveMountedSkillDecreases(oPlayer));
+         DelayCommand(1.1,HORSE_SupportAdjustMountedArcheryPenalty(oPlayer));
+         DelayCommand(1.2,HORSE_SupportOriginalSpeed(oPlayer));
+         if (!GetLocalInt(GetModule(),"X3_HORSE_NO_CORPSES"))
+         { // okay to create lootable horse corpses
+             sR=GetSkinString(oPlayer,"sX3_HorseResRef");
+             sT=GetSkinString(oPlayer,"sX3_HorseMountTag");
+             nCH=GetSkinInt(oPlayer,"nX3_HorseAppearance");
+             nST=GetSkinInt(oPlayer,"nX3_HorseTail");
+             nC=GetLocalInt(oPlayer,"nX3_HorsePortrait");
+             if (GetStringLength(sR)>0&&GetStringLeft(sR,GetStringLength(HORSE_PALADIN_PREFIX))!=HORSE_PALADIN_PREFIX)
+             { // create horse
+                 oHorse=HorseCreateHorse(sR,GetLocation(oPlayer),oPlayer,sT,nCH,nST);
+                 SetLootable(oHorse,TRUE);
+                 SetPortraitId(oHorse,nC);
+                 SetLocalInt(oHorse,"bDie",TRUE);
+                 AssignCommand(oHorse,SetIsDestroyable(FALSE,TRUE,TRUE));
+             } // create horse
+         } // okay to create lootable horse corpses
+         oInventory=GetLocalObject(oPlayer,"oX3_Saddlebags");
+         sID=GetLocalString(oPlayer,"sDB_Inv");
+         if (GetIsObjectValid(oInventory))
+         { // drop horse saddlebags
+             if (!GetIsObjectValid(oHorse))
+             { // no horse created
+                 HORSE_SupportTransferInventory(oInventory,OBJECT_INVALID,GetLocation(oPlayer),TRUE);
+             } // no horse created
+             else
+             { // transfer to horse
+                 HORSE_SupportTransferInventory(oInventory,oHorse,GetLocation(oHorse),TRUE);
+                 //DelayCommand(2.0,PurgeSkinObject(oHorse));
+                 //DelayCommand(3.0,KillTheHorse(oHorse));
+                 //DelayCommand(1.8,PurgeSkinObject(oHorse));
+             } // transfer to horse
+         } // drop horse saddlebags
+         else if (GetStringLength(sID)>0)
+         { // database based inventory
+             nC=GetCampaignInt(sDB,"nCO_"+sID);
+             while(nC>0)
+             { // restore inventory
+                 sR=GetCampaignString(sDB,"sR"+sID+IntToString(nC));
+                 sT=GetCampaignString(sDB,"sT"+sID+IntToString(nC));
+                 nST=GetCampaignInt(sDB,"nS"+sID+IntToString(nC));
+                 nCH=GetCampaignInt(sDB,"nC"+sID+IntToString(nC));
+                 DeleteCampaignVariable(sDB,"sR"+sID+IntToString(nC));
+                 DeleteCampaignVariable(sDB,"sT"+sID+IntToString(nC));
+                 DeleteCampaignVariable(sDB,"nS"+sID+IntToString(nC));
+                 DeleteCampaignVariable(sDB,"nC"+sID+IntToString(nC));
+                 if (!GetIsObjectValid(oHorse))
+                 { // no lootable corpse
+                     oItem=CreateObject(OBJECT_TYPE_ITEM,sR,GetLocation(oPlayer),FALSE,sT);
+                 } // no lootable corpse
+                 else
+                 { // lootable corpse
+                     oItem=CreateItemOnObject(sR,oHorse,nST,sT);
+                 } // lootable corpse
+                 if (GetItemStackSize(oItem)!=nST) SetItemStackSize(oItem,nST);
+                 if (nCH>0) SetItemCharges(oItem,nCH);
+                 nC--;
+             } // restore inventory
+             DeleteCampaignVariable(sDB,"nCO_"+sID);
+             //DelayCommand(2.0,PurgeSkinObject(oHorse));
+             if (GetIsObjectValid(oHorse)&&GetLocalInt(oHorse,"bDie")) DelayCommand(3.0,KillTheHorse(oHorse));
+             //DelayCommand(2.5,PurgeSkinObject(oHorse));
+         } // database based inventory
+         else if (GetIsObjectValid(oHorse))
+         { // no inventory
+             //DelayCommand(1.0,PurgeSkinObject(oHorse));
+             DelayCommand(2.0,KillTheHorse(oHorse));
+             //DelayCommand(1.8,PurgeSkinObject(oHorse));
+         } // no inventory
+         //eEffect=EffectDeath();
+         //DelayCommand(1.6,ApplyEffectToObject(DURATION_TYPE_INSTANT,eEffect,oPlayer));
+         //DelayCommand(1.7,SetCommandable(TRUE,oPlayer));
+         //return;
+     } // Dismount and then die
+ 
      // * increment global tracking number of times that I died
      SetLocalInt(oPlayer, "NW_L_PLAYER_DIED", GetLocalInt(oPlayer, "NW_L_PLAYER_DIED") + 1);
  
      // * BK: Automation Control. Autopcs ignore death
      if (GetLocalInt(oPlayer, "NW_L_AUTOMATION") == 10)
      {
          Raise(oPlayer);
          DelayCommand(1.0, ExecuteScript("crawl", OBJECT_SELF));
          return; // Raise and return
      }
  
***************
*** 117,127 ****
--- 222,234 ----
      {   SetLocalInt(oPlayer, "NW_G_Playerhasbeenbad", 10); // * Player bad
          SetStandardFactionReputation(STANDARD_FACTION_MERCHANT, 80, oPlayer);
      }
      if (GetStandardFactionReputation(STANDARD_FACTION_DEFENDER, oPlayer) <= 10)
      {   SetLocalInt(oPlayer, "NW_G_Playerhasbeenbad", 10); // * Player bad
          SetStandardFactionReputation(STANDARD_FACTION_DEFENDER, 80, oPlayer);
      }
  
      DelayCommand(2.5, PopUpGUIPanel(oPlayer,GUI_PANEL_PLAYER_DEATH));
  
  }
+ ///////////////////////////////////////////////////////////////[ MAIN ]/////////
+ 
*** nw_s0_bladebara.nss	Mon Aug 04 20:22:29 2008 *** modified PRC script ***
--- nw_s0_bladebara.nss	Mon Aug 04 20:18:14 2008
***************
*** 44,67 ****
          if (nMetaMagic == METAMAGIC_MAXIMIZE)
          {
              nDamage = nLevel * 6;//Damage is at max
          }
          else if (nMetaMagic == METAMAGIC_EMPOWER)
          {
              nDamage = nDamage + (nDamage/2);
          }
          //Make SR Check
          if (!MyResistSpell(GetAreaOfEffectCreator(), oTarget) )
          {
!             if(MySavingThrow(SAVING_THROW_REFLEX, oTarget, GetSpellSaveDC()))
!             {
!                 nDamage = nDamage/2;
!             }
              //Set damage effect
              eDam = EffectDamage(nDamage, DAMAGE_TYPE_SLASHING);
              //Apply damage and VFX
              ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget);
              ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget);
          }
      }
  }
  
--- 44,66 ----
          if (nMetaMagic == METAMAGIC_MAXIMIZE)
          {
              nDamage = nLevel * 6;//Damage is at max
          }
          else if (nMetaMagic == METAMAGIC_EMPOWER)
          {
              nDamage = nDamage + (nDamage/2);
          }
          //Make SR Check
          if (!MyResistSpell(GetAreaOfEffectCreator(), oTarget) )
          {
!             //Adjust damage according to Reflex Save, Evasion or Improved Evasion
!             nDamage = GetReflexAdjustedDamage(nDamage, oTarget, GetSpellSaveDC());
! 
              //Set damage effect
              eDam = EffectDamage(nDamage, DAMAGE_TYPE_SLASHING);
              //Apply damage and VFX
              ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget);
              ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget);
          }
      }
  }
  
*** nw_s0_bladebarc.nss	Mon Aug 04 20:22:29 2008 *** modified prc script ***
--- nw_s0_bladebarc.nss	Mon Aug 04 20:18:14 2008
***************
*** 62,87 ****
                  //Roll Damage
                  int nDamage = d6(nLevel);
                  //Enter Metamagic conditions
                  if(nMetaMagic == METAMAGIC_MAXIMIZE)
                  {
                      nDamage = nLevel * 6;//Damage is at max
                  }
                  else if (nMetaMagic == METAMAGIC_EMPOWER)
                  {
                      nDamage = nDamage + (nDamage/2);
                  }
!                 if(MySavingThrow(SAVING_THROW_REFLEX, oTarget, GetSpellSaveDC()))
!                 {
!                     nDamage = nDamage/2;
!                 }
                  //Set damage effect
                  eDam = EffectDamage(nDamage, DAMAGE_TYPE_SLASHING);
                  //Apply damage and VFX
                  ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget);
                  ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget);
              }
          }
          oTarget = GetNextInPersistentObject(OBJECT_SELF,OBJECT_TYPE_CREATURE | OBJECT_TYPE_PLACEABLE | OBJECT_TYPE_DOOR);
       }
  }
  
--- 62,87 ----
                  //Roll Damage
                  int nDamage = d6(nLevel);
                  //Enter Metamagic conditions
                  if(nMetaMagic == METAMAGIC_MAXIMIZE)
                  {
                      nDamage = nLevel * 6;//Damage is at max
                  }
                  else if (nMetaMagic == METAMAGIC_EMPOWER)
                  {
                      nDamage = nDamage + (nDamage/2);
                  }
! 
!                 //Adjust damage according to Reflex Save, Evasion or Improved Evasion
!                 nDamage = GetReflexAdjustedDamage(nDamage, oTarget, GetSpellSaveDC());
! 
                  //Set damage effect
                  eDam = EffectDamage(nDamage, DAMAGE_TYPE_SLASHING);
                  //Apply damage and VFX
                  ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget);
                  ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget);
              }
          }
          oTarget = GetNextInPersistentObject(OBJECT_SELF,OBJECT_TYPE_CREATURE | OBJECT_TYPE_PLACEABLE | OBJECT_TYPE_DOOR);
       }
  }
  
*** nw_s0_evardsa.nss	Mon Aug 04 20:22:29 2008 ***PRC script implements differently***
--- nw_s0_evardsa.nss	Mon Aug 04 20:18:14 2008
***************
*** 111,148 ****
                  nOppossedGrappleCheckModifiers = nOppossedGrappleCheckModifiers + 8;
              }
  
              for (nHits = nTentaclesPerTarget; nHits > 0; nHits--)
              {
                  // Grapple Check.
                  nTentacleGrappleCheck = d20() + nCasterLevel + 8; // Str(4) + Large Tentacle(4)
                  nOpposedGrappleCheck = d20() + nOppossedGrappleCheckModifiers;
  
                  if(nTentacleGrappleCheck >= nOpposedGrappleCheck)
                  {
!                     nDieDam = d6();
                      //Enter Metamagic conditions
                      if (nMetaMagic == METAMAGIC_MAXIMIZE)
                      {
!                         nDieDam = 6;//Damage is at max
!                     }
!                     nDamage = nDamage + nDieDam + 4;
!                 }
              }
              if (nMetaMagic == METAMAGIC_EMPOWER)
              {
!                 nDamage = nDamage + (nDamage/2); //Damage/Healing is +50%
              }
  
-             if(nDamage > 0)
-             {
                  fDelay = GetRandomDelay(1.0, 2.2);
!                 eDam = EffectDamage(nDamage, DAMAGE_TYPE_BLUDGEONING, DAMAGE_POWER_PLUS_TWO);
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget));
                  if(!MySavingThrow(SAVING_THROW_FORT, oTarget, GetSpellSaveDC(), SAVING_THROW_TYPE_NONE, OBJECT_SELF, fDelay))
                  {
                      DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(1)));
                  }
              }
          }
      }
  }
--- 111,150 ----
                  nOppossedGrappleCheckModifiers = nOppossedGrappleCheckModifiers + 8;
              }
  
              for (nHits = nTentaclesPerTarget; nHits > 0; nHits--)
              {
                  // Grapple Check.
                  nTentacleGrappleCheck = d20() + nCasterLevel + 8; // Str(4) + Large Tentacle(4)
                  nOpposedGrappleCheck = d20() + nOppossedGrappleCheckModifiers;
  
                  if(nTentacleGrappleCheck >= nOpposedGrappleCheck)
                  {
!                     nDieDam = d6() + 4;
                      //Enter Metamagic conditions
                      if (nMetaMagic == METAMAGIC_MAXIMIZE)
                      {
!                         nDieDam = 10;//Damage is at max 6+4=10
                      }
+ 
                      if (nMetaMagic == METAMAGIC_EMPOWER)
                      {
!                         nDieDam = nDieDam + (nDieDam/2); //Damage/Healing is +50%
                      }
+                     nDamage = nDamage + nDieDam;
  
                      fDelay = GetRandomDelay(1.0, 2.2);
!                     eDam = EffectDamage(nDieDam, DAMAGE_TYPE_BLUDGEONING, DAMAGE_POWER_PLUS_TWO);
                      DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget));
+                 }
+             }
+ 
+             if(nDamage > 0)
+             {
                  if(!MySavingThrow(SAVING_THROW_FORT, oTarget, GetSpellSaveDC(), SAVING_THROW_TYPE_NONE, OBJECT_SELF, fDelay))
                  {
                      DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(1)));
                  }
              }
          }
      }
  }
*** nw_s0_evardsc.nss	Mon Aug 04 20:22:29 2008 ***PRC script implements differently***
--- nw_s0_evardsc.nss	Mon Aug 04 20:18:14 2008
***************
*** 115,156 ****
                          nOppossedGrappleCheckModifiers = nOppossedGrappleCheckModifiers + 8;
                      }
  
                      for (nHits = nTentaclesPerTarget; nHits > 0; nHits--)
                      {
                          // Grapple Check.
                          nTentacleGrappleCheck = d20() + nCasterLevel + 8; // Str(4) + Large Tentacle(4)
                          nOpposedGrappleCheck = d20() + nOppossedGrappleCheckModifiers;
  
                          if(nTentacleGrappleCheck >= nOpposedGrappleCheck)
                          {
!                             nDieDam = d6();
                              //Enter Metamagic conditions
                              if (nMetaMagic == METAMAGIC_MAXIMIZE)
                              {
!                                 nDieDam = 6;//Damage is at max
!                             }
!                             nDamage = nDamage + nDieDam + 4;
!                         }
                      }
                      if (nMetaMagic == METAMAGIC_EMPOWER)
                      {
!                         nDamage = nDamage + (nDamage/2); //Damage/Healing is +50%
                      }
                  }
              }
  
              if(nDamage > 0)
              {
-                 eDam = EffectDamage(nDamage, DAMAGE_TYPE_BLUDGEONING, DAMAGE_POWER_PLUS_TWO);
-                 fDelay = GetRandomDelay(0.75, 1.5);
-                 DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget));
                  if(!MySavingThrow(SAVING_THROW_FORT, oTarget, GetSpellSaveDC(), SAVING_THROW_TYPE_NONE, OBJECT_SELF, fDelay))
                  {
                     DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(1)));
                  }
              }
  
              oTarget = GetNextInPersistentObject();
          }
      }
  }
--- 115,158 ----
                          nOppossedGrappleCheckModifiers = nOppossedGrappleCheckModifiers + 8;
                      }
  
                      for (nHits = nTentaclesPerTarget; nHits > 0; nHits--)
                      {
                          // Grapple Check.
                          nTentacleGrappleCheck = d20() + nCasterLevel + 8; // Str(4) + Large Tentacle(4)
                          nOpposedGrappleCheck = d20() + nOppossedGrappleCheckModifiers;
  
                          if(nTentacleGrappleCheck >= nOpposedGrappleCheck)
                          {
!                             nDieDam = d6() + 4;
                              //Enter Metamagic conditions
                              if (nMetaMagic == METAMAGIC_MAXIMIZE)
                              {
!                                 nDieDam = 10;//Damage is at max 6+4=10
                              }
+ 
                              if (nMetaMagic == METAMAGIC_EMPOWER)
                              {
!                                 nDieDam = nDieDam + (nDieDam/2); //Damage/Healing is +50%
!                             }
!                             nDamage = nDamage + nDieDam;
! 
!                             eDam = EffectDamage(nDieDam, DAMAGE_TYPE_BLUDGEONING, DAMAGE_POWER_PLUS_TWO);
!                             fDelay = GetRandomDelay(0.75, 1.5);
!                             DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget));
!                         }
                      }
                  }
              }
  
              if(nDamage > 0)
              {
                  if(!MySavingThrow(SAVING_THROW_FORT, oTarget, GetSpellSaveDC(), SAVING_THROW_TYPE_NONE, OBJECT_SELF, fDelay))
                  {
                     DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(1)));
                  }
              }
  
              oTarget = GetNextInPersistentObject();
          }
      }
  }
*** nw_s0_healcirc.nss	Mon Aug 04 20:20:42 2008 *** PRC script modified ***
--- NW_S0_HealCirc.nss	Mon Aug 04 20:18:14 2008
***************
*** 37,59 ****
      {
  	// If code within the PreSpellCastHook (i.e. UMD) reports FALSE, do not run this spell
          return;
      }
  
  // End of Spell Cast Hook
  
  
    //Declare major variables
    object oTarget;
    int nCasterLvl = GetCasterLevel(OBJECT_SELF);
!   int nDamagen, nModify, nHurt, nHP;
    int nMetaMagic = GetMetaMagicFeat();
    effect eKill;
    effect eHeal;
    effect eVis = EffectVisualEffect(VFX_IMP_SUNSTRIKE);
    effect eVis2 = EffectVisualEffect(VFX_IMP_HEALING_M);
    effect eImpact = EffectVisualEffect(VFX_FNF_LOS_HOLY_20);
    float fDelay;
    //Limit caster level
    if (nCasterLvl > 20)
    {
      nCasterLvl = 20;
--- 37,59 ----
      {
      // If code within the PreSpellCastHook (i.e. UMD) reports FALSE, do not run this spell
          return;
      }
  
  // End of Spell Cast Hook
  
  
    //Declare major variables
    object oTarget;
    int nCasterLvl = GetCasterLevel(OBJECT_SELF);
!   int nDamagen, nModify, nHP;
    int nMetaMagic = GetMetaMagicFeat();
    effect eKill;
    effect eHeal;
    effect eVis = EffectVisualEffect(VFX_IMP_SUNSTRIKE);
    effect eVis2 = EffectVisualEffect(VFX_IMP_HEALING_M);
    effect eImpact = EffectVisualEffect(VFX_FNF_LOS_HOLY_20);
    float fDelay;
    //Limit caster level
    if (nCasterLvl > 20)
    {
      nCasterLvl = 20;
***************
*** 72,126 ****
                  //Fire cast spell at event for the specified target
                  SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELL_HEALING_CIRCLE));
                  //Make SR check
                  if (!MyResistSpell(OBJECT_SELF, oTarget, fDelay))
                  {
                      nModify = d8() + nCasterLvl;
                      //Make metamagic check
                      if (nMetaMagic == METAMAGIC_MAXIMIZE)
                      {
                          nModify = 8 + nCasterLvl;
                      }
                      //Make Fort save
                      if (MySavingThrow(SAVING_THROW_FORT, oTarget, GetSpellSaveDC(), SAVING_THROW_TYPE_NONE, OBJECT_SELF, fDelay))
                      {
                          nModify /= 2;
                      }
!                     //Calculate damage
!                     nHurt =  nModify;
                      //Set damage effect
!                     eKill = EffectDamage(nHurt, DAMAGE_TYPE_POSITIVE);
                      //Apply damage effect and VFX impact
                      DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eKill, oTarget));
                      DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget));
                  }
              }
          }
          else
          {
              // * May 2003: Heal Neutrals as well
          	if(!GetIsReactionTypeHostile(oTarget) || GetFactionEqual(oTarget))
          	{
                  //Fire cast spell at event for the specified target
                  SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELL_HEALING_CIRCLE, FALSE));
!                 nHP = d8();
                  //Enter Metamagic conditions
                  if (nMetaMagic == METAMAGIC_MAXIMIZE)
                  {
!                     nHP =8;//Damage is at max
                  }
                  if (nMetaMagic == METAMAGIC_EMPOWER)
                  {
                      nHP = nHP + (nHP/2); //Damage/Healing is +50%
                  }
                  //Set healing effect
-                 nHP = nHP + nCasterLvl;
                  eHeal = EffectHeal(nHP);
                  //Apply heal effect and VFX impact
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eHeal, oTarget));
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis2, oTarget));
              }
          }
          //Get next target in the shape
          oTarget = GetNextObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_LARGE, GetSpellTargetLocation());
      }
  }
--- 72,129 ----
                  //Fire cast spell at event for the specified target
                  SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELL_HEALING_CIRCLE));
                  //Make SR check
                  if (!MyResistSpell(OBJECT_SELF, oTarget, fDelay))
                  {
                      nModify = d8() + nCasterLvl;
                      //Make metamagic check
                      if (nMetaMagic == METAMAGIC_MAXIMIZE)
                      {
                          nModify = 8 + nCasterLvl;
                      }
+                     if (nMetaMagic == METAMAGIC_EMPOWER)
+                     {
+                         nModify = nModify + (nModify/2); //Damage/Healing is +50%
+                     }
+ 
                      //Make Fort save
                      if (MySavingThrow(SAVING_THROW_FORT, oTarget, GetSpellSaveDC(), SAVING_THROW_TYPE_NONE, OBJECT_SELF, fDelay))
                      {
                          nModify /= 2;
                      }
! 
                      //Set damage effect
!                     eKill = EffectDamage(nModify, DAMAGE_TYPE_POSITIVE);
                      //Apply damage effect and VFX impact
                      DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eKill, oTarget));
                      DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget));
                  }
              }
          }
          else
          {
              // * May 2003: Heal Neutrals as well
              if(!GetIsReactionTypeHostile(oTarget) || GetFactionEqual(oTarget))
              {
                  //Fire cast spell at event for the specified target
                  SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELL_HEALING_CIRCLE, FALSE));
!                 nHP = d8() + nCasterLvl;
                  //Enter Metamagic conditions
                  if (nMetaMagic == METAMAGIC_MAXIMIZE)
                  {
!                     nHP = 8 + nCasterLvl;//Damage is at max
                  }
                  if (nMetaMagic == METAMAGIC_EMPOWER)
                  {
                      nHP = nHP + (nHP/2); //Damage/Healing is +50%
                  }
                  //Set healing effect
                  eHeal = EffectHeal(nHP);
                  //Apply heal effect and VFX impact
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eHeal, oTarget));
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis2, oTarget));
              }
          }
          //Get next target in the shape
          oTarget = GetNextObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_LARGE, GetSpellTargetLocation());
      }
  }
*** nw_s0_naturebal.nss	Mon Aug 04 20:22:29 2008 *** prc script modified***
--- nw_s0_naturebal.nss	Mon Aug 04 20:18:14 2008
***************
*** 38,72 ****
  // End of Spell Cast Hook
  
  
      //Declare major variables
      effect eHeal;
      effect eVis = EffectVisualEffect(VFX_IMP_HEALING_L);
      effect eSR;
      effect eVis2 = EffectVisualEffect(VFX_IMP_BREACH);
      effect eNature = EffectVisualEffect(VFX_FNF_NATURES_BALANCE);
      effect eDur = EffectVisualEffect(VFX_DUR_CESSATE_NEGATIVE);
  
!     int nRand;
      int nCasterLevel = GetCasterLevel(OBJECT_SELF);
      //Determine spell duration as an integer for later conversion to Rounds, Turns or Hours.
      int nDuration = nCasterLevel/3;
      int nMetaMagic = GetMetaMagicFeat();
      float fDelay;
      //Set off fire and forget visual
      ApplyEffectAtLocation(DURATION_TYPE_INSTANT, eNature, GetLocation(OBJECT_SELF));
      //Declare the spell shape, size and the location.  Capture the first target object in the shape.
      if (nMetaMagic == METAMAGIC_EXTEND)
      {
          nDuration = nDuration *2;   //Duration is +100%
      }
      object oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_LARGE, GetLocation(OBJECT_SELF), FALSE);
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while(GetIsObjectValid(oTarget))
      {
          fDelay = GetRandomDelay();
          //Check to see how the caster feels about the targeted object
          if(GetIsFriend(oTarget))
          {
                //Fire cast spell at event for the specified target
                SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELL_NATURES_BALANCE, FALSE));
                nRand = d8(3) + nCasterLevel;
--- 38,79 ----
  // End of Spell Cast Hook
  
  
      //Declare major variables
      effect eHeal;
      effect eVis = EffectVisualEffect(VFX_IMP_HEALING_L);
      effect eSR;
      effect eVis2 = EffectVisualEffect(VFX_IMP_BREACH);
      effect eNature = EffectVisualEffect(VFX_FNF_NATURES_BALANCE);
      effect eDur = EffectVisualEffect(VFX_DUR_CESSATE_NEGATIVE);
  
!     int nRand, nNumDice;
      int nCasterLevel = GetCasterLevel(OBJECT_SELF);
      //Determine spell duration as an integer for later conversion to Rounds, Turns or Hours.
      int nDuration = nCasterLevel/3;
      int nMetaMagic = GetMetaMagicFeat();
      float fDelay;
      //Set off fire and forget visual
      ApplyEffectAtLocation(DURATION_TYPE_INSTANT, eNature, GetLocation(OBJECT_SELF));
      //Declare the spell shape, size and the location.  Capture the first target object in the shape.
      if (nMetaMagic == METAMAGIC_EXTEND)
      {
          nDuration = nDuration *2;   //Duration is +100%
      }
+ 
+     nNumDice = nCasterLevel / 5;
+     if(nNumDice == 0)
+     {
+         nNumDice = 1;
+     }
+ 
      object oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_LARGE, GetLocation(OBJECT_SELF), FALSE);
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while(GetIsObjectValid(oTarget))
      {
          fDelay = GetRandomDelay();
          //Check to see how the caster feels about the targeted object
          if(GetIsFriend(oTarget))
          {
                //Fire cast spell at event for the specified target
                SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELL_NATURES_BALANCE, FALSE));
                nRand = d8(3) + nCasterLevel;
***************
*** 86,117 ****
          }
          else
          if (spellsIsTarget(oTarget, SPELL_TARGET_STANDARDHOSTILE, OBJECT_SELF))
          {
              //Fire cast spell at event for the specified target
              SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELL_NATURES_BALANCE));
              if(!GetIsReactionTypeFriendly(oTarget))
              {
                  //Check for saving throw
                  if (!MySavingThrow(SAVING_THROW_WILL, oTarget, GetSpellSaveDC()))
                  {
!                       nCasterLevel /= 5;
!                       if(nCasterLevel == 0)
!                       {
!                         nCasterLevel = 1;
!                       }
!                       nRand = d4(nCasterLevel);
                        //Enter Metamagic conditions
                        if (nMetaMagic == METAMAGIC_MAXIMIZE)
                        {
!                          nRand = 4 * nCasterLevel;//Damage is at max
                        }
                        else if (nMetaMagic == METAMAGIC_EMPOWER)
                        {
                           nRand = nRand + (nRand/2); //Damage/Healing is +50%
                        }
                        eSR = EffectSpellResistanceDecrease(nRand);
                        effect eLink = EffectLinkEffects(eSR, eDur);
                        //Apply reduce SR effects
                        DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(nDuration)));
                        DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis2, oTarget));
                  }
--- 93,119 ----
          }
          else
          if (spellsIsTarget(oTarget, SPELL_TARGET_STANDARDHOSTILE, OBJECT_SELF))
          {
              //Fire cast spell at event for the specified target
              SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELL_NATURES_BALANCE));
              if(!GetIsReactionTypeFriendly(oTarget))
              {
                  //Check for saving throw
                  if (!MySavingThrow(SAVING_THROW_WILL, oTarget, GetSpellSaveDC()))
                  {
!                       nRand = d4(nNumDice);
                        //Enter Metamagic conditions
                        if (nMetaMagic == METAMAGIC_MAXIMIZE)
                        {
!                          nRand = 4 * nNumDice;//Damage is at max
                        }
                        else if (nMetaMagic == METAMAGIC_EMPOWER)
                        {
                           nRand = nRand + (nRand/2); //Damage/Healing is +50%
                        }
                        eSR = EffectSpellResistanceDecrease(nRand);
                        effect eLink = EffectLinkEffects(eSR, eDur);
                        //Apply reduce SR effects
                        DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(nDuration)));
                        DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis2, oTarget));
                  }
*** nw_s0_negburst.nss	Mon Aug 04 20:20:43 2008 ***prc script modified***
--- NW_S0_NegBurst.nss	Mon Aug 04 20:18:14 2008
***************
*** 33,89 ****
          return;
      }
  
  // End of Spell Cast Hook
  
  
      //Declare major variables
      object oCaster = OBJECT_SELF;
      int nCasterLvl = GetCasterLevel(oCaster);
      int nMetaMagic = GetMetaMagicFeat();
      int nDamage;
      float fDelay;
      effect eExplode = EffectVisualEffect(VFX_FNF_LOS_EVIL_20); //Replace with Negative Pulse
      effect eVis = EffectVisualEffect(VFX_IMP_NEGATIVE_ENERGY);
      effect eVisHeal = EffectVisualEffect(VFX_IMP_HEALING_M);
      effect eDam, eHeal;
      int nStr = nCasterLvl / 4;
      if (nStr == 0)
      {
          nStr = 1;
      }
      effect eStr = EffectAbilityIncrease(ABILITY_STRENGTH, nStr);
      effect eStr_Low = EffectAbilityDecrease(ABILITY_STRENGTH, nStr);
      effect eDur = EffectVisualEffect(VFX_DUR_CESSATE_POSITIVE);
      effect eDur2 = EffectVisualEffect(VFX_DUR_CESSATE_NEGATIVE);
      
      effect eGood = EffectLinkEffects(eStr, eDur);
      effect eBad = EffectLinkEffects(eStr_Low, eDur2);
  
      //Get the spell target location as opposed to the spell target.
      location lTarget = GetSpellTargetLocation();
      //Apply the explosion at the location captured above.
      ApplyEffectAtLocation(DURATION_TYPE_INSTANT, eExplode, lTarget);
      //Declare the spell shape, size and the location.  Capture the first target object in the shape.
      object oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_HUGE, lTarget);
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while (GetIsObjectValid(oTarget))
      {
         if(spellsIsTarget(oTarget, SPELL_TARGET_STANDARDHOSTILE, OBJECT_SELF))
         {
              //Roll damage for each target
!             nDamage = d8() + nCasterLvl;
              //Resolve metamagic
      	    if (nMetaMagic == METAMAGIC_MAXIMIZE)
              {
!                 nDamage = 8 + nCasterLvl;
              }
      	        else if (nMetaMagic == METAMAGIC_EMPOWER)
              {
                 nDamage = nDamage + (nDamage / 2);
              }
              if(MySavingThrow(SAVING_THROW_WILL, oTarget, GetSpellSaveDC(), SAVING_THROW_TYPE_NEGATIVE, OBJECT_SELF, fDelay))
              {
                  nDamage /= 2;
              }
              //Get the distance between the explosion and the target to calculate delay
              fDelay = GetDistanceBetweenLocations(lTarget, GetLocation(oTarget))/20;
--- 33,97 ----
          return;
      }
  
  // End of Spell Cast Hook
  
  
      //Declare major variables
      object oCaster = OBJECT_SELF;
      int nCasterLvl = GetCasterLevel(oCaster);
      int nMetaMagic = GetMetaMagicFeat();
      int nDamage;
+     int nAdditionalLevelDamage;
      float fDelay;
      effect eExplode = EffectVisualEffect(VFX_FNF_LOS_EVIL_20); //Replace with Negative Pulse
      effect eVis = EffectVisualEffect(VFX_IMP_NEGATIVE_ENERGY);
      effect eVisHeal = EffectVisualEffect(VFX_IMP_HEALING_M);
      effect eDam, eHeal;
      int nStr = nCasterLvl / 4;
      if (nStr == 0)
      {
          nStr = 1;
      }
+ 
+     nAdditionalLevelDamage = nCasterLvl;
+     if ( nAdditionalLevelDamage > 20 )
+     {
+        nAdditionalLevelDamage = 20;
+     }
+ 
      effect eStr = EffectAbilityIncrease(ABILITY_STRENGTH, nStr);
      effect eStr_Low = EffectAbilityDecrease(ABILITY_STRENGTH, nStr);
      effect eDur = EffectVisualEffect(VFX_DUR_CESSATE_POSITIVE);
      effect eDur2 = EffectVisualEffect(VFX_DUR_CESSATE_NEGATIVE);
  
      effect eGood = EffectLinkEffects(eStr, eDur);
      effect eBad = EffectLinkEffects(eStr_Low, eDur2);
  
      //Get the spell target location as opposed to the spell target.
      location lTarget = GetSpellTargetLocation();
      //Apply the explosion at the location captured above.
      ApplyEffectAtLocation(DURATION_TYPE_INSTANT, eExplode, lTarget);
      //Declare the spell shape, size and the location.  Capture the first target object in the shape.
      object oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_HUGE, lTarget);
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while (GetIsObjectValid(oTarget))
      {
         if(spellsIsTarget(oTarget, SPELL_TARGET_STANDARDHOSTILE, OBJECT_SELF))
         {
              //Roll damage for each target
!             nDamage = d8() + nAdditionalLevelDamage;
              //Resolve metamagic
              if (nMetaMagic == METAMAGIC_MAXIMIZE)
              {
!                 nDamage = 8 + nAdditionalLevelDamage;
              }
                  else if (nMetaMagic == METAMAGIC_EMPOWER)
              {
                 nDamage = nDamage + (nDamage / 2);
              }
              if(MySavingThrow(SAVING_THROW_WILL, oTarget, GetSpellSaveDC(), SAVING_THROW_TYPE_NEGATIVE, OBJECT_SELF, fDelay))
              {
                  nDamage /= 2;
              }
              //Get the distance between the explosion and the target to calculate delay
              fDelay = GetDistanceBetweenLocations(lTarget, GetLocation(oTarget))/20;
*** nw_s1_gazefear.nss	Mon Aug 04 20:20:44 2008 *** not in PRC***
--- nw_s1_gazefear.nss	Mon Aug 04 20:18:14 2008
***************
*** 30,59 ****
      effect eGaze = EffectFrightened();
      effect eVis = EffectVisualEffect(VFX_IMP_FEAR_S);
      effect eDur = EffectVisualEffect(VFX_DUR_CESSATE_NEGATIVE);
      effect eVisDur = EffectVisualEffect(VFX_DUR_MIND_AFFECTING_FEAR);
  
      effect eLink = EffectLinkEffects(eGaze, eVisDur);
      eLink = EffectLinkEffects(eLink, eDur);
      //Get first target in spell area
      oTarget = GetFirstObjectInShape(SHAPE_SPELLCONE, 10.0, lTargetLocation, TRUE);
      while(GetIsObjectValid(oTarget))
      {
-         nDuration = GetScaledDuration(nDuration , oTarget);
          if(GetIsEnemy(oTarget) && oTarget != OBJECT_SELF)
          {
              //Fire cast spell at event for the specified target
              SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELLABILITY_GAZE_FEAR));
              //Determine effect delay
              float fDelay = GetDistanceBetween(OBJECT_SELF, oTarget)/20;
              if(!MySavingThrow(SAVING_THROW_WILL, oTarget, nDC, SAVING_THROW_TYPE_FEAR, OBJECT_SELF, fDelay))
              {
                  //Apply the VFX impact and effects
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget));
!                 DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(nDuration)));
              }
          }
          //Get next target in spell area
          oTarget = GetNextObjectInShape(SHAPE_SPELLCONE, 10.0, lTargetLocation, TRUE);
      }
  }
  
--- 30,58 ----
      effect eGaze = EffectFrightened();
      effect eVis = EffectVisualEffect(VFX_IMP_FEAR_S);
      effect eDur = EffectVisualEffect(VFX_DUR_CESSATE_NEGATIVE);
      effect eVisDur = EffectVisualEffect(VFX_DUR_MIND_AFFECTING_FEAR);
  
      effect eLink = EffectLinkEffects(eGaze, eVisDur);
      eLink = EffectLinkEffects(eLink, eDur);
      //Get first target in spell area
      oTarget = GetFirstObjectInShape(SHAPE_SPELLCONE, 10.0, lTargetLocation, TRUE);
      while(GetIsObjectValid(oTarget))
      {
          if(GetIsEnemy(oTarget) && oTarget != OBJECT_SELF)
          {
              //Fire cast spell at event for the specified target
              SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELLABILITY_GAZE_FEAR));
              //Determine effect delay
              float fDelay = GetDistanceBetween(OBJECT_SELF, oTarget)/20;
              if(!MySavingThrow(SAVING_THROW_WILL, oTarget, nDC, SAVING_THROW_TYPE_FEAR, OBJECT_SELF, fDelay))
              {
                  //Apply the VFX impact and effects
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget));
!                 DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(GetScaledDuration(nDuration , oTarget))));
              }
          }
          //Get next target in spell area
          oTarget = GetNextObjectInShape(SHAPE_SPELLCONE, 10.0, lTargetLocation, TRUE);
      }
  }
  
*** nw_s1_howlfear.nss	Mon Aug 04 20:20:44 2008 *** not in prc ***
--- nw_s1_howlfear.nss	Mon Aug 04 20:18:14 2008
***************
*** 33,60 ****
      int nHD = GetHitDice(OBJECT_SELF);
      int nDC = 10 + (nHD/4);
      int nDuration = 1 + (nHD/4);
      ApplyEffectToObject(DURATION_TYPE_INSTANT, eImpact, OBJECT_SELF);
      //Get first target in spell area
      object oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_COLOSSAL, GetLocation(OBJECT_SELF));
      while(GetIsObjectValid(oTarget))
      {
      	if(GetIsEnemy(oTarget) && oTarget != OBJECT_SELF)
      	{
              fDelay = GetDistanceToObject(oTarget)/10;
-             nDuration = GetScaledDuration(nDuration , oTarget);
              //Fire cast spell at event for the specified target
              SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELLABILITY_HOWL_FEAR));
  
              //Make a saving throw check
              if(!/*Will Save*/ MySavingThrow(SAVING_THROW_WILL, oTarget, nDC, SAVING_THROW_TYPE_FEAR))
              {
                  //Apply the VFX impact and effects
!                 DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(nDuration)));
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget));
              }
          }
          //Get next target in spell area
          oTarget = GetNextObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_COLOSSAL, GetLocation(OBJECT_SELF));
      }
  }
  
--- 33,59 ----
      int nHD = GetHitDice(OBJECT_SELF);
      int nDC = 10 + (nHD/4);
      int nDuration = 1 + (nHD/4);
      ApplyEffectToObject(DURATION_TYPE_INSTANT, eImpact, OBJECT_SELF);
      //Get first target in spell area
      object oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_COLOSSAL, GetLocation(OBJECT_SELF));
      while(GetIsObjectValid(oTarget))
      {
          if(GetIsEnemy(oTarget) && oTarget != OBJECT_SELF)
          {
              fDelay = GetDistanceToObject(oTarget)/10;
              //Fire cast spell at event for the specified target
              SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELLABILITY_HOWL_FEAR));
  
              //Make a saving throw check
              if(!/*Will Save*/ MySavingThrow(SAVING_THROW_WILL, oTarget, nDC, SAVING_THROW_TYPE_FEAR))
              {
                  //Apply the VFX impact and effects
!                 DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eLink, oTarget, RoundsToSeconds(GetScaledDuration(nDuration , oTarget))));
                  DelayCommand(fDelay, ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget));
              }
          }
          //Get next target in spell area
          oTarget = GetNextObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_COLOSSAL, GetLocation(OBJECT_SELF));
      }
  }
  
*** nw_s2_elemshape.nss	Mon Aug 04 20:22:29 2008 ***prc script modified***
--- nw_s2_elemshape.nss	Mon Aug 04 20:18:14 2008
***************
*** 2,36 ****
--- 2,60 ----
  //:: Elemental Shape
  //:: NW_S2_ElemShape
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Allows the Druid to change into elemental forms.
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Jan 22, 2002
  //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified Date: January 15th-16th, 2008
+ //:://////////////////////////////////////////////
+ /*
+     Modified to insure no shapeshifting spells are castable upon
+     mounted targets.  This prevents problems that can occur due
+     to dismounting after shape shifting, or other issues that can
+     occur due to preserved appearances getting out of synch.
+ 
+     This can additional check can be disabled by setting the variable
+     X3_NO_SHAPESHIFT_SPELL_CHECK to 1 on the module object.  If this
+     variable is set then this script will function as it did prior to
+     this modification.
+ 
+ */
  
  
  #include "x2_inc_itemprop"
+ #include "x3_inc_horse"
  void main()
  {
      //Declare major variables
      int nSpell = GetSpellId();
      object oTarget = GetSpellTargetObject();
      effect eVis = EffectVisualEffect(VFX_IMP_POLYMORPH);
      effect ePoly;
      int nPoly;
      int nDuration = GetLevelByClass(CLASS_TYPE_DRUID); //GetCasterLevel(OBJECT_SELF);
      int bElder = FALSE;
+     if (!GetLocalInt(GetModule(),"X3_NO_SHAPESHIFT_SPELL_CHECK"))
+     { // check to see if abort due to being mounted
+         if (HorseGetIsMounted(oTarget))
+         { // abort
+             if (GetIsPC(oTarget)) FloatingTextStrRefOnCreature(111982,oTarget,FALSE);
+             return;
+         } // abort
+     } // check to see if abort due to being mounted
      if(GetLevelByClass(CLASS_TYPE_DRUID) >= 20)
      {
          bElder = TRUE;
      }
      //Determine Polymorph subradial type
      if(bElder == FALSE)
      {
          if(nSpell == 397)
          {
              nPoly = POLYMORPH_TYPE_HUGE_FIRE_ELEMENTAL;
          }
*** nw_s2_wildshape.nss	Mon Aug 04 20:22:29 2008 *** prc script modified***
--- nw_s2_wildshape.nss	Mon Aug 04 20:18:14 2008
***************
*** 7,41 ****
--- 7,65 ----
      Allows the Druid to change into animal forms.
  
      Updated: Sept 30 2003, Georg Z.
        * Made Armor merge with druid to make forms
          more useful.
  
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Jan 22, 2002
  //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified Date: January 15th-16th, 2008
+ //:://////////////////////////////////////////////
+ /*
+     Modified to insure no shapeshifting spells are castable upon
+     mounted targets.  This prevents problems that can occur due
+     to dismounting after shape shifting, or other issues that can
+     occur due to preserved appearances getting out of synch.
+ 
+     This can additional check can be disabled by setting the variable
+     X3_NO_SHAPESHIFT_SPELL_CHECK to 1 on the module object.  If this
+     variable is set then this script will function as it did prior to
+     this modification.
+ 
+ */
  
  #include "x2_inc_itemprop"
+ #include "x3_inc_horse"
  
  void main()
  {
      //Declare major variables
      int nSpell = GetSpellId();
      object oTarget = GetSpellTargetObject();
      effect eVis = EffectVisualEffect(VFX_IMP_POLYMORPH);
      effect ePoly;
      int nPoly;
      int nMetaMagic = GetMetaMagicFeat();
      int nDuration = GetLevelByClass(CLASS_TYPE_DRUID);
+     if (!GetLocalInt(GetModule(),"X3_NO_SHAPESHIFT_SPELL_CHECK"))
+     { // check to see if abort due to being mounted
+         if (HorseGetIsMounted(oTarget))
+         { // abort
+             if (GetIsPC(oTarget)) FloatingTextStrRefOnCreature(111982,oTarget,FALSE);
+             return;
+         } // abort
+     } // check to see if abort due to being mounted
      //Enter Metamagic conditions
      if (nMetaMagic == METAMAGIC_EXTEND)
      {
          nDuration = nDuration *2; //Duration is +100%
      }
  
      //Determine Polymorph subradial type
      if(nSpell == 401)
      {
          nPoly = POLYMORPH_TYPE_BROWN_BEAR;
          if (nDuration >= 12)
*** nw_t1_negavgc.nss	Mon Aug 04 20:20:44 2008  *** not in prc***
--- nw_t1_negavgc.nss	Mon Aug 04 20:18:14 2008
***************
*** 15,34 ****
--- 15,45 ----
  #include "NW_I0_SPELLS"
  
  void main()
  {
      //Declare major variables
      object oTarget = GetEnteringObject();
      effect eNeg = EffectAbilityDecrease(ABILITY_STRENGTH, 1);
      effect eDam = EffectDamage(d6(3), DAMAGE_TYPE_NEGATIVE);
      eNeg = SupernaturalEffect(eNeg);
      effect eVis = EffectVisualEffect(VFX_IMP_REDUCE_ABILITY_SCORE);
  
+     // Undead are healed by Negative Energy.
+     if ( GetRacialType(oTarget) == RACIAL_TYPE_UNDEAD )
+     {
+         effect eHeal = EffectHeal(d6(3));
+         effect eVisHeal = EffectVisualEffect(VFX_IMP_HEALING_M);
+         ApplyEffectToObject(DURATION_TYPE_INSTANT, eHeal, oTarget);
+         ApplyEffectToObject(DURATION_TYPE_INSTANT, eVisHeal, oTarget);
+     }
+     else
+     {
          //Make a saving throw check
          if(!MySavingThrow(SAVING_THROW_FORT,oTarget, 15, SAVING_THROW_TYPE_TRAP))
          {
              ApplyEffectToObject(DURATION_TYPE_PERMANENT, eNeg, oTarget);
          }
          //Apply the VFX impact and effects
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget);
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget);
+     }
  }
*** nw_t1_negdeadc.nss	Mon Aug 04 20:20:44 2008 *** not in prc ***
--- nw_t1_negdeadc.nss	Mon Aug 04 20:18:14 2008
***************
*** 14,33 ****
--- 14,44 ----
  #include "NW_I0_SPELLS"
  
  void main()
  {
      //Declare major variables
      object oTarget = GetEnteringObject();
      effect eNeg = EffectNegativeLevel(1);
      effect eDam = EffectDamage(d6(8), DAMAGE_TYPE_NEGATIVE);
      eNeg = SupernaturalEffect(eNeg);
      effect eVis = EffectVisualEffect(VFX_IMP_REDUCE_ABILITY_SCORE);
  
+     // Undead are healed by Negative Energy.
+     if ( GetRacialType(oTarget) == RACIAL_TYPE_UNDEAD )
+     {
+         effect eHeal = EffectHeal(d6(8));
+         effect eVisHeal = EffectVisualEffect(VFX_IMP_HEALING_M);
+         ApplyEffectToObject(DURATION_TYPE_INSTANT, eHeal, oTarget);
+         ApplyEffectToObject(DURATION_TYPE_INSTANT, eVisHeal, oTarget);
+     }
+     else
+     {
          //Make a saving throw check
          if(!MySavingThrow(SAVING_THROW_FORT, oTarget, 21, SAVING_THROW_TYPE_TRAP))
          {
              ApplyEffectToObject(DURATION_TYPE_PERMANENT, eNeg, oTarget);
          }
          //Apply the VFX impact and effects
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget);
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget);
+     }
  }
*** nw_t1_negminc.nss	Mon Aug 04 20:20:44 2008 *** not in prc ***
--- nw_t1_negminc.nss	Mon Aug 04 20:18:14 2008
***************
*** 15,34 ****
--- 15,45 ----
  #include "NW_I0_SPELLS"
  
  void main()
  {
      //Declare major variables
      object oTarget = GetEnteringObject();
      effect eNeg = EffectAbilityDecrease(ABILITY_STRENGTH, 1);
      effect eDam = EffectDamage(d6(2), DAMAGE_TYPE_NEGATIVE);
      eNeg = SupernaturalEffect(eNeg);
      effect eVis = EffectVisualEffect(VFX_IMP_REDUCE_ABILITY_SCORE);
  
+     // Undead are healed by Negative Energy.
+     if ( GetRacialType(oTarget) == RACIAL_TYPE_UNDEAD )
+     {
+         effect eHeal = EffectHeal(d6(2));
+         effect eVisHeal = EffectVisualEffect(VFX_IMP_HEALING_M);
+         ApplyEffectToObject(DURATION_TYPE_INSTANT, eHeal, oTarget);
+         ApplyEffectToObject(DURATION_TYPE_INSTANT, eVisHeal, oTarget);
+     }
+     else
+     {
          //Make a saving throw check
          if(!MySavingThrow(SAVING_THROW_FORT, oTarget, 12, SAVING_THROW_TYPE_TRAP))
          {
              ApplyEffectToObject(DURATION_TYPE_PERMANENT, eNeg, oTarget);
          }
          //Apply the VFX impact and effects
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget);
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget);
+     }
  }
*** nw_t1_negstrc.nss	Mon Aug 04 20:20:44 2008 *** not in prc ***
--- nw_t1_negstrc.nss	Mon Aug 04 20:18:14 2008
***************
*** 15,34 ****
--- 15,45 ----
  #include "NW_I0_SPELLS"
  
  void main()
  {
      //Declare major variables
      object oTarget = GetEnteringObject();
      effect eNeg = EffectAbilityDecrease(ABILITY_STRENGTH, 2);
      effect eDam = EffectDamage(d6(5), DAMAGE_TYPE_NEGATIVE);
      eNeg = SupernaturalEffect(eNeg);
      effect eVis = EffectVisualEffect(VFX_IMP_REDUCE_ABILITY_SCORE);
  
+     // Undead are healed by Negative Energy.
+     if ( GetRacialType(oTarget) == RACIAL_TYPE_UNDEAD )
+     {
+         effect eHeal = EffectHeal(d6(5));
+         effect eVisHeal = EffectVisualEffect(VFX_IMP_HEALING_M);
+         ApplyEffectToObject(DURATION_TYPE_INSTANT, eHeal, oTarget);
+         ApplyEffectToObject(DURATION_TYPE_INSTANT, eVisHeal, oTarget);
+     }
+     else
+     {
          //Make a saving throw check
          if(!MySavingThrow(SAVING_THROW_FORT, oTarget, 18, SAVING_THROW_TYPE_TRAP))
          {
              ApplyEffectToObject(DURATION_TYPE_PERMANENT, eNeg, oTarget);
          }
          //Apply the VFX impact and effects
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eDam, oTarget);
          ApplyEffectToObject(DURATION_TYPE_INSTANT, eVis, oTarget);
+     }
  }
*** nwscript.nss	Mon Aug 04 20:22:29 2008
--- nwscript.nss	Mon Aug 04 20:18:13 2008
***************
*** 30,51 ****
--- 30,53 ----
  
  int    ATTITUDE_NEUTRAL         = 0;
  int    ATTITUDE_AGGRESSIVE      = 1;
  int    ATTITUDE_DEFENSIVE       = 2;
  int    ATTITUDE_SPECIAL         = 3;
  
  int    TALKVOLUME_TALK          = 0;
  int    TALKVOLUME_WHISPER       = 1;
  int    TALKVOLUME_SHOUT         = 2;
  int    TALKVOLUME_SILENT_TALK   = 3;
  int    TALKVOLUME_SILENT_SHOUT  = 4;
+ int    TALKVOLUME_PARTY         = 5;
+ int    TALKVOLUME_TELL          = 6;
  
  int    INVENTORY_SLOT_HEAD      = 0;
  int    INVENTORY_SLOT_CHEST     = 1;
  int    INVENTORY_SLOT_BOOTS     = 2;
  int    INVENTORY_SLOT_ARMS      = 3;
  int    INVENTORY_SLOT_RIGHTHAND = 4;
  int    INVENTORY_SLOT_LEFTHAND  = 5;
  int    INVENTORY_SLOT_CLOAK     = 6;
  int    INVENTORY_SLOT_LEFTRING  = 7;
  int    INVENTORY_SLOT_RIGHTRING = 8;
  int    INVENTORY_SLOT_NECK      = 9;
***************
*** 649,670 ****
--- 651,676 ----
  
  int ITEM_PROPERTY_MONSTER_DAMAGE                           = 77 ;
  int ITEM_PROPERTY_IMMUNITY_SPELLS_BY_LEVEL                 = 78 ;
  
  int ITEM_PROPERTY_SPECIAL_WALK                             = 79;
  int ITEM_PROPERTY_HEALERS_KIT                              = 80;
  int ITEM_PROPERTY_WEIGHT_INCREASE                          = 81;
  int ITEM_PROPERTY_ONHITCASTSPELL                           = 82;
  int ITEM_PROPERTY_VISUALEFFECT                             = 83;
  int ITEM_PROPERTY_ARCANE_SPELL_FAILURE                     = 84;
  
+ int ITEM_PROPERTY_MATERIAL                                 = 85;
+ int ITEM_PROPERTY_QUALITY                                  = 86;
+ int ITEM_PROPERTY_ADDITIONAL                               = 87;
+ 
  
  int BASE_ITEM_SHORTSWORD            = 0;
  int BASE_ITEM_LONGSWORD             = 1;
  int BASE_ITEM_BATTLEAXE             = 2;
  int BASE_ITEM_BASTARDSWORD          = 3;
  int BASE_ITEM_LIGHTFLAIL            = 4;
  int BASE_ITEM_WARHAMMER             = 5;
  int BASE_ITEM_HEAVYCROSSBOW         = 6;
  int BASE_ITEM_LIGHTCROSSBOW         = 7;
  int BASE_ITEM_LONGBOW               = 8;
  int BASE_ITEM_LIGHTMACE             = 9;
***************
*** 1087,1130 ****
--- 1093,1163 ----
  int VFX_EYES_RED_FLAME_DWARF_MALE      = 362;
  int VFX_EYES_RED_FLAME_DWARF_FEMALE    = 363;
  int VFX_EYES_RED_FLAME_ELF_MALE        = 364;
  int VFX_EYES_RED_FLAME_ELF_FEMALE      = 365;
  int VFX_EYES_RED_FLAME_GNOME_MALE      = 366;
  int VFX_EYES_RED_FLAME_GNOME_FEMALE    = 367;
  int VFX_EYES_RED_FLAME_HALFLING_MALE   = 368;
  int VFX_EYES_RED_FLAME_HALFLING_FEMALE = 369;
  int VFX_EYES_RED_FLAME_HALFORC_MALE    = 370;
  int VFX_EYES_RED_FLAME_HALFORC_FEMALE  = 371;
  int VFX_EYES_RED_FLAME_TROGLODYTE      = 372;
+ int VFX_EYES_YEL_HUMAN_MALE            = 373;
+ int VFX_EYES_YEL_HUMAN_FEMALE          = 374;
+ int VFX_EYES_YEL_DWARF_MALE            = 375;
+ int VFX_EYES_YEL_DWARF_FEMALE          = 376;
+ int VFX_EYES_YEL_ELF_MALE              = 377;
+ int VFX_EYES_YEL_ELF_FEMALE            = 378;
+ int VFX_EYES_YEL_GNOME_MALE            = 379;
+ int VFX_EYES_YEL_GNOME_FEMALE          = 380;
+ int VFX_EYES_YEL_HALFLING_MALE         = 381;
+ int VFX_EYES_YEL_HALFLING_FEMALE       = 382;
+ int VFX_EYES_YEL_HALFORC_MALE          = 383;
+ int VFX_EYES_YEL_HALFORC_FEMALE        = 384;
+ int VFX_EYES_YEL_TROGLODYTE            = 385;
+ int VFX_EYES_ORG_HUMAN_MALE            = 386;
+ int VFX_EYES_ORG_HUMAN_FEMALE          = 387;
+ int VFX_EYES_ORG_DWARF_MALE            = 388;
+ int VFX_EYES_ORG_DWARF_FEMALE          = 389;
+ int VFX_EYES_ORG_ELF_MALE              = 390;
+ int VFX_EYES_ORG_ELF_FEMALE            = 391;
+ int VFX_EYES_ORG_GNOME_MALE            = 392;
+ int VFX_EYES_ORG_GNOME_FEMALE          = 393;
+ int VFX_EYES_ORG_HALFLING_MALE         = 394;
+ int VFX_EYES_ORG_HALFLING_FEMALE       = 395;
+ int VFX_EYES_ORG_HALFORC_MALE          = 396;
+ int VFX_EYES_ORG_HALFORC_FEMALE        = 397;
+ int VFX_EYES_ORG_TROGLODYTE            = 398;
  int VFX_DUR_IOUNSTONE                  = 403;
  int VFX_IMP_TORNADO                    = 407;
  int VFX_DUR_GLOW_LIGHT_BLUE            = 408;
  int VFX_DUR_GLOW_PURPLE                = 409;
  int VFX_DUR_GLOW_BLUE                  = 410;
  int VFX_DUR_GLOW_RED                   = 411;
  int VFX_DUR_GLOW_LIGHT_RED             = 412;
  int VFX_DUR_GLOW_YELLOW                = 413;
  int VFX_DUR_GLOW_LIGHT_YELLOW          = 414;
  int VFX_DUR_GLOW_GREEN                 = 415;
  int VFX_DUR_GLOW_LIGHT_GREEN           = 416;
  int VFX_DUR_GLOW_ORANGE                = 417;
  int VFX_DUR_GLOW_LIGHT_ORANGE          = 418;
  int VFX_DUR_GLOW_BROWN                 = 419;
  int VFX_DUR_GLOW_LIGHT_BROWN           = 420;
  int VFX_DUR_GLOW_GREY                  = 421;
  int VFX_DUR_GLOW_WHITE                 = 422;
  int VFX_DUR_GLOW_LIGHT_PURPLE          = 423;
  int VFX_DUR_GHOST_TRANSPARENT          = 424;
  int VFX_DUR_GHOST_SMOKE                = 425;
  int VFX_DUR_GLYPH_OF_WARDING           = 445;
  int VFX_FNF_SOUND_BURST_SILENT         = 446;
+ int VFX_BEAM_DISINTEGRATE              = 447;
  int VFX_FNF_ELECTRIC_EXPLOSION         = 459;
  int VFX_IMP_DUST_EXPLOSION             = 460;
  int VFX_IMP_PULSE_HOLY_SILENT          = 461;
  int VFX_DUR_DEATH_ARMOR                = 463;
  int VFX_DUR_ICESKIN                    = 465;
  int VFX_FNF_SWINGING_BLADE             = 473;
  int VFX_DUR_INFERNO                    = 474;
  int VFX_FNF_DEMON_HAND                 = 475;
  int VFX_DUR_STONEHOLD                  = 476;
  int VFX_FNF_MYSTICAL_EXPLOSION         = 477;
  int VFX_DUR_GHOSTLY_VISAGE_NO_SOUND    = 478;
***************
*** 1211,1234 ****
  int VFX_EYES_GREEN_DWARF_MALE          = 569;
  int VFX_EYES_GREEN_DWARF_FEMALE        = 570;
  int VFX_EYES_GREEN_ELF_MALE            = 571;
  int VFX_EYES_GREEN_ELF_FEMALE          = 572;
  int VFX_EYES_GREEN_GNOME_MALE          = 573;
  int VFX_EYES_GREEN_GNOME_FEMALE        = 574;
  int VFX_EYES_GREEN_HALFLING_MALE       = 575;
  int VFX_EYES_GREEN_HALFLING_FEMALE     = 576;
  int VFX_EYES_GREEN_HALFORC_MALE        = 577;
  int VFX_EYES_GREEN_HALFORC_FEMALE      = 578;
  int VFX_EYES_GREEN_TROGLODYTE          = 579;
! 
! 
  
  //VFX_Persistent.2da
  int AOE_PER_FOGACID                = 0;
  int AOE_PER_FOGFIRE                = 1;
  int AOE_PER_FOGSTINK               = 2;
  int AOE_PER_FOGKILL                = 3;
  int AOE_PER_FOGMIND                = 4;
  int AOE_PER_WALLFIRE               = 5;
  int AOE_PER_WALLWIND               = 6;
  int AOE_PER_WALLBLADE              = 7;
  int AOE_PER_WEB                    = 8;
--- 1244,1324 ----
  int VFX_EYES_GREEN_DWARF_MALE          = 569;
  int VFX_EYES_GREEN_DWARF_FEMALE        = 570;
  int VFX_EYES_GREEN_ELF_MALE            = 571;
  int VFX_EYES_GREEN_ELF_FEMALE          = 572;
  int VFX_EYES_GREEN_GNOME_MALE          = 573;
  int VFX_EYES_GREEN_GNOME_FEMALE        = 574;
  int VFX_EYES_GREEN_HALFLING_MALE       = 575;
  int VFX_EYES_GREEN_HALFLING_FEMALE     = 576;
  int VFX_EYES_GREEN_HALFORC_MALE        = 577;
  int VFX_EYES_GREEN_HALFORC_FEMALE      = 578;
  int VFX_EYES_GREEN_TROGLODYTE          = 579;
! int VFX_EYES_PUR_HUMAN_MALE            = 580;
! int VFX_EYES_PUR_HUMAN_FEMALE          = 581;
! int VFX_EYES_PUR_DWARF_MALE            = 582;
! int VFX_EYES_PUR_DWARF_FEMALE          = 583;
! int VFX_EYES_PUR_ELF_MALE              = 584;
! int VFX_EYES_PUR_ELF_FEMALE            = 585;
! int VFX_EYES_PUR_GNOME_MALE            = 586;
! int VFX_EYES_PUR_GNOME_FEMALE          = 587;
! int VFX_EYES_PUR_HALFLING_MALE         = 588;
! int VFX_EYES_PUR_HALFLING_FEMALE       = 589;
! int VFX_EYES_PUR_HALFORC_MALE          = 590;
! int VFX_EYES_PUR_HALFORC_FEMALE        = 591;
! int VFX_EYES_PUR_TROGLODYTE            = 592;
! int VFX_EYES_CYN_HUMAN_MALE            = 593;
! int VFX_EYES_CYN_HUMAN_FEMALE          = 594;
! int VFX_EYES_CYN_DWARF_MALE            = 595;
! int VFX_EYES_CYN_DWARF_FEMALE          = 596;
! int VFX_EYES_CYN_ELF_MALE              = 597;
! int VFX_EYES_CYN_ELF_FEMALE            = 598;
! int VFX_EYES_CYN_GNOME_MALE            = 599;
! int VFX_EYES_CYN_GNOME_FEMALE          = 600;
! int VFX_EYES_CYN_HALFLING_MALE         = 601;
! int VFX_EYES_CYN_HALFLING_FEMALE       = 602;
! int VFX_EYES_CYN_HALFORC_MALE          = 603;
! int VFX_EYES_CYN_HALFORC_FEMALE        = 604;
! int VFX_EYES_CYN_TROGLODYTE            = 605;
! int VFX_EYES_WHT_HUMAN_MALE            = 606;
! int VFX_EYES_WHT_HUMAN_FEMALE          = 607;
! int VFX_EYES_WHT_DWARF_MALE            = 608;
! int VFX_EYES_WHT_DWARF_FEMALE          = 609;
! int VFX_EYES_WHT_ELF_MALE              = 610;
! int VFX_EYES_WHT_ELF_FEMALE            = 611;
! int VFX_EYES_WHT_GNOME_MALE            = 612;
! int VFX_EYES_WHT_GNOME_FEMALE          = 613;
! int VFX_EYES_WHT_HALFLING_MALE         = 614;
! int VFX_EYES_WHT_HALFLING_FEMALE       = 615;
! int VFX_EYES_WHT_HALFORC_MALE          = 616;
! int VFX_EYES_WHT_HALFORC_FEMALE        = 617;
! int VFX_EYES_WHT_TROGLODYTE            = 618;
! int VFX_IMP_PDK_GENERIC_PULSE          = 623;
! int VFX_IMP_PDK_GENERIC_HEAD_HIT       = 624;
! int VFX_IMP_PDK_RALLYING_CRY           = 625;
! int VFX_IMP_PDK_HEROIC_SHIELD          = 626;
! int VFX_IMP_PDK_INSPIRE_COURAGE        = 627;
! int VFX_DUR_PDK_FEAR                   = 628;
! int VFX_IMP_PDK_WRATH                  = 629;
! int VFX_IMP_PDK_OATH                   = 630;
! int VFX_IMP_PDK_FINAL_STAND            = 631;
! int VFX_DUR_ARROW_IN_STERNUM           = 632;
! int VFX_DUR_ARROW_IN_CHEST_LEFT        = 633;
! int VFX_DUR_ARROW_IN_CHEST_RIGHT       = 634;
! int VFX_DUR_ARROW_IN_BACK              = 635;
! int VFX_DUR_ARROW_IN_TEMPLES           = 636;
! int VFX_DUR_ARROW_IN_FACE              = 637;
! int VFX_DUR_ARROW_IN_HEAD              = 638;
! int VFX_DUR_QUILL_IN_CHEST             = 639;
! int VFX_IMP_STARBURST_GREEN            = 644;
! int VFX_IMP_STARBURST_RED              = 645;
! int VFX_IMP_NIGHTMARE_HEAD_HIT         = 670;
  
  //VFX_Persistent.2da
  int AOE_PER_FOGACID                = 0;
  int AOE_PER_FOGFIRE                = 1;
  int AOE_PER_FOGSTINK               = 2;
  int AOE_PER_FOGKILL                = 3;
  int AOE_PER_FOGMIND                = 4;
  int AOE_PER_WALLFIRE               = 5;
  int AOE_PER_WALLWIND               = 6;
  int AOE_PER_WALLBLADE              = 7;
  int AOE_PER_WEB                    = 8;
***************
*** 1862,1883 ****
--- 1952,1981 ----
  
  int SPELL_CRAFT_ADD_ITEM_PROPERTY          = 654;
  int SPELL_CRAFT_POISON_WEAPON_OR_AMMO      = 655;
  
  int SPELL_CRAFT_CRAFT_WEAPON_SKILL         = 656;
  int SPELL_CRAFT_CRAFT_ARMOR_SKILL          = 657;
  int SPELLABILITY_DRAGON_BREATH_NEGATIVE    = 698;
  int SPELLABILITY_SEAHAG_EVILEYE            = 803;
  int SPELLABILITY_AURA_HORRIFICAPPEARANCE   = 804;
  int SPELLABILITY_TROGLODYTE_STENCH         = 805;
  
+ int SPELL_HORSE_MENU                       = 812;
+ int SPELL_HORSE_MOUNT                      = 813;
+ int SPELL_HORSE_DISMOUNT                   = 814;
+ int SPELL_HORSE_PARTY_MOUNT                = 815;
+ int SPELL_HORSE_PARTY_DISMOUNT             = 816;
+ int SPELL_HORSE_ASSIGN_MOUNT               = 817;
+ int SPELL_PALADIN_SUMMON_MOUNT             = 818;
+ 
  // these constants must match those in poison.2da
  int POISON_NIGHTSHADE                    = 0;
  int POISON_SMALL_CENTIPEDE_POISON        = 1;
  int POISON_BLADE_BANE                    = 2;
  int POISON_GREENBLOOD_OIL                = 3;
  int POISON_BLOODROOT                     = 4;
  int POISON_PURPLE_WORM_POISON            = 5;
  int POISON_LARGE_SCORPION_VENOM          = 6;
  int POISON_WYVERN_POISON                 = 7;
  int POISON_BLUE_WHINNIS                  = 8;
  int POISON_GIANT_WASP_POISON             = 9;
***************
*** 2000,2021 ****
--- 2098,2120 ----
  int CLASS_TYPE_WEAPON_MASTER           = 33;
  int CLASS_TYPE_PALEMASTER       = 34;
  int CLASS_TYPE_PALE_MASTER       = 34;
  int CLASS_TYPE_SHIFTER          = 35;
  int CLASS_TYPE_DWARVENDEFENDER  = 36;
  int CLASS_TYPE_DWARVEN_DEFENDER  = 36;
  int CLASS_TYPE_DRAGONDISCIPLE   = 37;
  int CLASS_TYPE_DRAGON_DISCIPLE   = 37;
  int CLASS_TYPE_OOZE             = 38;
  int CLASS_TYPE_EYE_OF_GRUUMSH   = 39;
  int CLASS_TYPE_SHOU_DISCIPLE    = 40;
+ int CLASS_TYPE_PURPLE_DRAGON_KNIGHT = 41;
  
  int CLASS_TYPE_INVALID   = 255;
  
  // These are for the LevelUpHenchman command.
  int PACKAGE_BARBARIAN                    = 0;
  int PACKAGE_BARD                         = 1;
  int PACKAGE_CLERIC                       = 2;
  int PACKAGE_DRUID                        = 3;
  int PACKAGE_FIGHTER                      = 4;
  int PACKAGE_MONK                         = 5;
  int PACKAGE_PALADIN                      = 6;
***************
*** 2173,2194 ****
--- 2272,2294 ----
  int SKILL_SPELLCRAFT       = 16;
  int SKILL_SPOT             = 17;
  int SKILL_TAUNT            = 18;
  int SKILL_USE_MAGIC_DEVICE = 19;
  int SKILL_APPRAISE         = 20;
  int SKILL_TUMBLE           = 21;
  int SKILL_CRAFT_TRAP       = 22;
  int SKILL_BLUFF            = 23;
  int SKILL_INTIMIDATE       = 24;
  int SKILL_CRAFT_ARMOR      = 25;
  int SKILL_CRAFT_WEAPON     = 26;
+ int SKILL_RIDE             = 27;
  
  int SKILL_ALL_SKILLS       = 255;
  
  int SUBSKILL_FLAGTRAP      = 100;
  int SUBSKILL_RECOVERTRAP   = 101;
  int SUBSKILL_EXAMINETRAP   = 102;
  
  int FEAT_ALERTNESS                      = 0;
  int FEAT_AMBIDEXTERITY                  = 1;
  int FEAT_ARMOR_PROFICIENCY_HEAVY        = 2;
  int FEAT_ARMOR_PROFICIENCY_LIGHT        = 3;
***************
*** 3190,3211 ****
--- 3290,3346 ----
  int FEAT_EPIC_SHIFTER_INFINITE_WILDSHAPE_1 = 1062;
  int FEAT_EPIC_SHIFTER_INFINITE_WILDSHAPE_2 = 1063;
  int FEAT_EPIC_SHIFTER_INFINITE_WILDSHAPE_3 = 1064;
  int FEAT_EPIC_SHIFTER_INFINITE_WILDSHAPE_4 = 1065;
  int FEAT_EPIC_SHIFTER_INFINITE_HUMANOID_SHAPE = 1066;
  int FEAT_EPIC_BARBARIAN_DAMAGE_REDUCTION = 1067;
  int FEAT_EPIC_DRUID_INFINITE_WILDSHAPE   = 1068;
  int FEAT_EPIC_DRUID_INFINITE_ELEMENTAL_SHAPE = 1069;
  int FEAT_PRESTIGE_POISON_SAVE_EPIC       = 1070;
  int FEAT_EPIC_SUPERIOR_WEAPON_FOCUS      = 1071;
  
+ int FEAT_WEAPON_FOCUS_TRIDENT               = 1072;
+ int FEAT_WEAPON_SPECIALIZATION_TRIDENT      = 1073;
+ int FEAT_IMPROVED_CRITICAL_TRIDENT          = 1074;
+ int FEAT_EPIC_DEVASTATING_CRITICAL_TRIDENT  = 1075;
+ int FEAT_EPIC_WEAPON_FOCUS_TRIDENT          = 1076;
+ int FEAT_EPIC_WEAPON_SPECIALIZATION_TRIDENT = 1077;
+ int FEAT_EPIC_OVERWHELMING_CRITICAL_TRIDENT = 1078;
+ int FEAT_WEAPON_OF_CHOICE_TRIDENT           = 1079;
+ int FEAT_PDK_RALLY                          = 1080;
+ int FEAT_PDK_SHIELD                         = 1081;
+ int FEAT_PDK_FEAR                           = 1082;
+ int FEAT_PDK_WRATH                          = 1083;
+ int FEAT_PDK_STAND                          = 1084;
+ int FEAT_PDK_INSPIRE_1                      = 1085;
+ int FEAT_PDK_INSPIRE_2                      = 1086;
+ int FEAT_MOUNTED_COMBAT                     = 1087;
+ int FEAT_MOUNTED_ARCHERY                    = 1088;
+ int FEAT_HORSE_MENU                         = 1089;
+ int FEAT_HORSE_MOUNT                        = 1090;
+ int FEAT_HORSE_DISMOUNT                     = 1091;
+ int FEAT_HORSE_PARTY_MOUNT                  = 1092;
+ int FEAT_HORSE_PARTY_DISMOUNT               = 1093;
+ int FEAT_HORSE_ASSIGN_MOUNT                 = 1094;
+ int FEAT_PALADIN_SUMMON_MOUNT               = 1095;
+ int FEAT_PLAYER_TOOL_01                     = 1106;
+ int FEAT_PLAYER_TOOL_02                     = 1107;
+ int FEAT_PLAYER_TOOL_03                     = 1108;
+ int FEAT_PLAYER_TOOL_04                     = 1109;
+ int FEAT_PLAYER_TOOL_05                     = 1110;
+ int FEAT_PLAYER_TOOL_06                     = 1111;
+ int FEAT_PLAYER_TOOL_07                     = 1112;
+ int FEAT_PLAYER_TOOL_08                     = 1113;
+ int FEAT_PLAYER_TOOL_09                     = 1114;
+ int FEAT_PLAYER_TOOL_10                     = 1115;
+ 
  // Special Attack Defines
  int SPECIAL_ATTACK_INVALID              =   0;
  int SPECIAL_ATTACK_CALLED_SHOT_LEG      =   1;
  int SPECIAL_ATTACK_CALLED_SHOT_ARM      =   2;
  int SPECIAL_ATTACK_SAP                  =   3;
  int SPECIAL_ATTACK_DISARM               =   4;
  int SPECIAL_ATTACK_IMPROVED_DISARM      =   5;
  int SPECIAL_ATTACK_KNOCKDOWN            =   6;
  int SPECIAL_ATTACK_IMPROVED_KNOCKDOWN   =   7;
  int SPECIAL_ATTACK_STUNNING_FIST        =   8;
  int SPECIAL_ATTACK_FLURRY_OF_BLOWS      =   9;
***************
*** 3256,3277 ****
--- 3391,3424 ----
  int ANIMATION_LOOPING_SPASM                    = 20;
  int ANIMATION_LOOPING_CUSTOM1                  = 21;
  int ANIMATION_LOOPING_CUSTOM2                  = 22;
  int ANIMATION_LOOPING_CUSTOM3                  = 23;
  int ANIMATION_LOOPING_CUSTOM4                  = 24;
  int ANIMATION_LOOPING_CUSTOM5                  = 25;
  int ANIMATION_LOOPING_CUSTOM6                  = 26;
  int ANIMATION_LOOPING_CUSTOM7                  = 27;
  int ANIMATION_LOOPING_CUSTOM8                  = 28;
  int ANIMATION_LOOPING_CUSTOM9                  = 29;
  int ANIMATION_LOOPING_CUSTOM10                 = 30;
+ int ANIMATION_LOOPING_CUSTOM11                 = 31;
+ int ANIMATION_LOOPING_CUSTOM12                 = 32;
+ int ANIMATION_LOOPING_CUSTOM13                 = 33;
+ int ANIMATION_LOOPING_CUSTOM14                 = 34;
+ int ANIMATION_LOOPING_CUSTOM15                 = 35;
+ int ANIMATION_LOOPING_CUSTOM16                 = 36;
+ int ANIMATION_LOOPING_CUSTOM17                 = 37;
+ int ANIMATION_LOOPING_CUSTOM18                 = 38;
+ int ANIMATION_LOOPING_CUSTOM19                 = 39;
+ int ANIMATION_LOOPING_CUSTOM20                 = 40;
+ int ANIMATION_MOUNT1                           = 41;
+ int ANIMATION_DISMOUNT1                        = 42;
  
  // Fire and forget animation constants.
  int ANIMATION_FIREFORGET_HEAD_TURN_LEFT        = 100;
  int ANIMATION_FIREFORGET_HEAD_TURN_RIGHT       = 101;
  int ANIMATION_FIREFORGET_PAUSE_SCRATCH_HEAD    = 102;
  int ANIMATION_FIREFORGET_PAUSE_BORED           = 103;
  int ANIMATION_FIREFORGET_SALUTE                = 104;
  int ANIMATION_FIREFORGET_BOW                   = 105;
  int ANIMATION_FIREFORGET_STEAL                 = 106;
  int ANIMATION_FIREFORGET_GREETING              = 107;
  int ANIMATION_FIREFORGET_TAUNT                 = 108;
***************
*** 4261,4282 ****
--- 4408,4431 ----
  int IP_CONST_ABILITY_STR                        = 0;
  int IP_CONST_ABILITY_DEX                        = 1;
  int IP_CONST_ABILITY_CON                        = 2;
  int IP_CONST_ABILITY_INT                        = 3;
  int IP_CONST_ABILITY_WIS                        = 4;
  int IP_CONST_ABILITY_CHA                        = 5;
  int IP_CONST_ACMODIFIERTYPE_DODGE               = 0;
  int IP_CONST_ACMODIFIERTYPE_NATURAL             = 1;
  int IP_CONST_ACMODIFIERTYPE_ARMOR               = 2;
  int IP_CONST_ACMODIFIERTYPE_SHIELD              = 3;
  int IP_CONST_ACMODIFIERTYPE_DEFLECTION          = 4;
+ int IP_CONST_ADDITIONAL_UNKNOWN                 = 0;
+ int IP_CONST_ADDITIONAL_CURSED                  = 1;
  int IP_CONST_ALIGNMENTGROUP_ALL                 = 0;
  int IP_CONST_ALIGNMENTGROUP_NEUTRAL             = 1;
  int IP_CONST_ALIGNMENTGROUP_LAWFUL              = 2;
  int IP_CONST_ALIGNMENTGROUP_CHAOTIC             = 3;
  int IP_CONST_ALIGNMENTGROUP_GOOD                = 4;
  int IP_CONST_ALIGNMENTGROUP_EVIL                = 5;
  int IP_CONST_ALIGNMENT_LG                       = 0;
  int IP_CONST_ALIGNMENT_LN                       = 1;
  int IP_CONST_ALIGNMENT_LE                       = 2;
  int IP_CONST_ALIGNMENT_NG                       = 3;
  int IP_CONST_ALIGNMENT_TN                       = 4;
***************
*** 4413,4434 ****
--- 4562,4593 ----
  int IP_CONST_FEAT_WHIRLWIND                     = 29;
  int IP_CONST_FEAT_RAPID_SHOT                    = 30;
  int IP_CONST_FEAT_HIDE_IN_PLAIN_SIGHT           = 31;
  int IP_CONST_FEAT_SNEAK_ATTACK_1D6              = 32;
  int IP_CONST_FEAT_SNEAK_ATTACK_2D6              = 33;
  int IP_CONST_FEAT_SNEAK_ATTACK_3D6              = 34;
  int IP_CONST_FEAT_SHIELD_PROFICIENCY            = 35;
  int IP_CONST_FEAT_USE_POISON                    = 36;
  int IP_CONST_FEAT_DISARM_WHIP                   = 37;
  int IP_CONST_FEAT_WEAPON_PROF_CREATURE          = 38;
  int IP_CONST_FEAT_SNEAK_ATTACK_5D6              = 39;
+ int IP_CONST_FEAT_PLAYER_TOOL_01                = 53;
+ int IP_CONST_FEAT_PLAYER_TOOL_02                = 54;
+ int IP_CONST_FEAT_PLAYER_TOOL_03                = 55;
+ int IP_CONST_FEAT_PLAYER_TOOL_04                = 56;
+ int IP_CONST_FEAT_PLAYER_TOOL_05                = 57;
+ int IP_CONST_FEAT_PLAYER_TOOL_06                = 58;
+ int IP_CONST_FEAT_PLAYER_TOOL_07                = 59;
+ int IP_CONST_FEAT_PLAYER_TOOL_08                = 60;
+ int IP_CONST_FEAT_PLAYER_TOOL_09                = 61;
+ int IP_CONST_FEAT_PLAYER_TOOL_10                = 62;
  int IP_CONST_IMMUNITYMISC_BACKSTAB              = 0;
  int IP_CONST_IMMUNITYMISC_LEVEL_ABIL_DRAIN      = 1;
  int IP_CONST_IMMUNITYMISC_MINDSPELLS            = 2;
  int IP_CONST_IMMUNITYMISC_POISON                = 3;
  int IP_CONST_IMMUNITYMISC_DISEASE               = 4;
  int IP_CONST_IMMUNITYMISC_FEAR                  = 5;
  int IP_CONST_IMMUNITYMISC_KNOCKDOWN             = 6;
  int IP_CONST_IMMUNITYMISC_PARALYSIS             = 7;
  int IP_CONST_IMMUNITYMISC_CRITICAL_HITS         = 8;
  int IP_CONST_IMMUNITYMISC_DEATH_MAGIC           = 9;
  int IP_CONST_LIGHTBRIGHTNESS_DIM                = 1;
***************
*** 4684,4705 ****
--- 4843,4880 ----
  int IP_CONST_ONHIT_CASTSPELL_DEAFENING_CLNG                     = 137;
  int IP_CONST_ONHIT_CASTSPELL_KNOCKDOWN                          = 138;
  int IP_CONST_ONHIT_CASTSPELL_FREEZE                             = 139;
  int IP_CONST_ONHIT_CASTSPELL_COMBUST                            = 140;
  
  int IP_CONST_POISON_1D2_STRDAMAGE               = 0;
  int IP_CONST_POISON_1D2_DEXDAMAGE               = 1;
  int IP_CONST_POISON_1D2_CONDAMAGE               = 2;
  int IP_CONST_POISON_1D2_INTDAMAGE               = 3;
  int IP_CONST_POISON_1D2_WISDAMAGE               = 4;
  int IP_CONST_POISON_1D2_CHADAMAGE               = 5;
+ int IP_CONST_QUALITY_UNKOWN                     = 0;
+ int IP_CONST_QUALITY_DESTROYED                  = 1;
+ int IP_CONST_QUALITY_RUINED                     = 2;
+ int IP_CONST_QUALITY_VERY_POOR                  = 3;
+ int IP_CONST_QUALITY_POOR                       = 4;
+ int IP_CONST_QUALITY_BELOW_AVERAGE              = 5;
+ int IP_CONST_QUALITY_AVERAGE                    = 6;
+ int IP_CONST_QUALITY_ABOVE_AVERAGE              = 7;
+ int IP_CONST_QUALITY_GOOD                       = 8;
+ int IP_CONST_QUALITY_VERY_GOOD                  = 9;
+ int IP_CONST_QUALITY_EXCELLENT                  = 10;
+ int IP_CONST_QUALITY_MASTERWORK                 = 11;
+ int IP_CONST_QUALITY_GOD_LIKE                   = 12;
+ int IP_CONST_QUALITY_RAW                        = 13;
+ int IP_CONST_QUALITY_CUT                        = 14;
+ int IP_CONST_QUALITY_POLISHED                   = 15;
  int IP_CONST_CONTAINERWEIGHTRED_20_PERCENT      = 1;
  int IP_CONST_CONTAINERWEIGHTRED_40_PERCENT      = 2;
  int IP_CONST_CONTAINERWEIGHTRED_60_PERCENT      = 3;
  int IP_CONST_CONTAINERWEIGHTRED_80_PERCENT      = 4;
  int IP_CONST_CONTAINERWEIGHTRED_100_PERCENT     = 5;
  int IP_CONST_DAMAGERESIST_5                     = 1;
  int IP_CONST_DAMAGERESIST_10                    = 2;
  int IP_CONST_DAMAGERESIST_15                    = 3;
  int IP_CONST_DAMAGERESIST_20                    = 4;
  int IP_CONST_DAMAGERESIST_25                    = 5;
  int IP_CONST_DAMAGERESIST_30                    = 6;
***************
*** 5507,5528 ****
--- 5682,5704 ----
  int FOOTSTEP_TYPE_BEETLE                        = 6;
  int FOOTSTEP_TYPE_SPIDER                        = 7;
  int FOOTSTEP_TYPE_SKELETON                      = 8;
  int FOOTSTEP_TYPE_LEATHER_WING                  = 9;
  int FOOTSTEP_TYPE_FEATHER_WING                  = 10;
  //int FOOTSTEP_TYPE_LIZARD                      = 11; // Was not ever used/fully implemented.
  int FOOTSTEP_TYPE_NONE                          = 12;
  int FOOTSTEP_TYPE_SEAGULL                       = 13;
  int FOOTSTEP_TYPE_SHARK                         = 14;
  int FOOTSTEP_TYPE_WATER_NORMAL                  = 15;
  int FOOTSTEP_TYPE_WATER_LARGE                   = 16;
+ int FOOTSTEP_TYPE_HORSE                         = 17;
  int FOOTSTEP_TYPE_DEFAULT                       = 65535;
  
  // these constants must match those in the WingModel.2da
  int CREATURE_WING_TYPE_NONE                     = 0;
  int CREATURE_WING_TYPE_DEMON                    = 1;
  int CREATURE_WING_TYPE_ANGEL                    = 2;
  int CREATURE_WING_TYPE_BAT                      = 3;
  int CREATURE_WING_TYPE_DRAGON                   = 4;
  int CREATURE_WING_TYPE_BUTTERFLY                = 5;
  int CREATURE_WING_TYPE_BIRD                     = 6;
  
***************
*** 5550,5571 ****
--- 5726,5752 ----
  int CREATURE_PART_RIGHT_SHOULDER                = 14;    
  int CREATURE_PART_LEFT_SHOULDER                 = 15;   
  int CREATURE_PART_RIGHT_HAND                    = 16;
  int CREATURE_PART_LEFT_HAND                     = 17;
  int CREATURE_PART_HEAD                          = 20;
  
  int CREATURE_MODEL_TYPE_NONE                    = 0;
  int CREATURE_MODEL_TYPE_SKIN                    = 1;
  int CREATURE_MODEL_TYPE_TATTOO                  = 2;
  int CREATURE_MODEL_TYPE_UNDEAD                  = 255;
  
+ int COLOR_CHANNEL_SKIN                          = 0;
+ int COLOR_CHANNEL_HAIR                          = 1;
+ int COLOR_CHANNEL_TATTOO_1                      = 2;
+ int COLOR_CHANNEL_TATTOO_2                      = 3;
+ 
  // The following resrefs must match those in the tileset's set file.
  string TILESET_RESREF_BEHOLDER_CAVES    = "tib01";
  string TILESET_RESREF_CASTLE_INTERIOR   = "tic01";
  string TILESET_RESREF_CITY_EXTERIOR     = "tcn01";
  string TILESET_RESREF_CITY_INTERIOR     = "tin01";
  string TILESET_RESREF_CRYPT             = "tdc01";
  string TILESET_RESREF_DESERT            = "ttd01";
  string TILESET_RESREF_DROW_INTERIOR     = "tid01";
  string TILESET_RESREF_DUNGEON           = "tde01";
  string TILESET_RESREF_FOREST            = "ttf01";
  string TILESET_RESREF_FROZEN_WASTES     = "tti01";
***************
*** 5984,6007 ****
  string GetStringLeft(string sString, int nCount);
  
  // Insert sString into sDestination at nPosition
  // * Return value on error: ""
  string InsertString(string sDestination, string sString, int nPosition);
  
  // Get nCount characters from sString, starting at nStart
  // * Return value on error: ""
  string GetSubString(string sString, int nStart, int nCount);
  
  // Find the position of sSubstring inside sString
  // * Return value on error: -1
! int FindSubString(string sString, string sSubString);
  
  // math operations
  
  // Maths operation: absolute value of fValue
  float fabs(float fValue);
  
  // Maths operation: cosine of fValue
  float cos(float fValue);
  
  // Maths operation: sine of fValue
  float sin(float fValue);
--- 6165,6189 ----
  string GetStringLeft(string sString, int nCount);
  
  // Insert sString into sDestination at nPosition
  // * Return value on error: ""
  string InsertString(string sDestination, string sString, int nPosition);
  
  // Get nCount characters from sString, starting at nStart
  // * Return value on error: ""
  string GetSubString(string sString, int nStart, int nCount);
  
  // Find the position of sSubstring inside sString
+ // - nStart: The character position to start searching at (from the left end of the string). 
  // * Return value on error: -1
! int FindSubString(string sString, string sSubString, int nStart=0);
  
  // math operations
  
  // Maths operation: absolute value of fValue
  float fabs(float fValue);
  
  // Maths operation: cosine of fValue
  float cos(float fValue);
  
  // Maths operation: sine of fValue
  float sin(float fValue);
***************
*** 6713,6736 ****
  //      good/evil alignment values in the direction which is towards neutrality.
  //     e.g. If oSubject has a law/chaos value of 10 (i.e. chaotic) and a
  //          good/evil value of 80 (i.e. good) then if nShift is 15, the
  //          law/chaos value will become (10+15)=25 and the good/evil value will
  //          become (80-25)=55
  //     Furthermore, the shift will at most take the alignment value to 50 and
  //     not beyond.
  //     e.g. If oSubject has a law/chaos value of 40 and a good/evil value of 70,
  //          then if nShift is 15, the law/chaos value will become 50 and the
  //          good/evil value will become 55
  // - nShift: this is the desired shift in alignment
  // * No return value
! void AdjustAlignment(object oSubject, int nAlignment, int nShift);
  
  // Do nothing for fSeconds seconds.
  void ActionWait(float fSeconds);
  
  // Set the transition bitmap of a player; this should only be called in area
  // transition scripts. This action should be run by the person "clicking" the
  // area transition via AssignCommand.
  // - nPredefinedAreaTransition:
  //   -> To use a predefined area transition bitmap, use one of AREA_TRANSITION_*
  //   -> To use a custom, user-defined area transition bitmap, use
  //      AREA_TRANSITION_USER_DEFINED and specify the filename in the second
--- 6895,6921 ----
  //      good/evil alignment values in the direction which is towards neutrality.
  //     e.g. If oSubject has a law/chaos value of 10 (i.e. chaotic) and a
  //          good/evil value of 80 (i.e. good) then if nShift is 15, the
  //          law/chaos value will become (10+15)=25 and the good/evil value will
  //          become (80-25)=55
  //     Furthermore, the shift will at most take the alignment value to 50 and
  //     not beyond.
  //     e.g. If oSubject has a law/chaos value of 40 and a good/evil value of 70,
  //          then if nShift is 15, the law/chaos value will become 50 and the
  //          good/evil value will become 55
  // - nShift: this is the desired shift in alignment
+ // - bAllPartyMembers: when TRUE the alignment shift of oSubject also has a 
+ //                     diminished affect all members of oSubject's party (if oSubject is a Player).
+ //                     When FALSE the shift only affects oSubject.
  // * No return value
! void AdjustAlignment(object oSubject, int nAlignment, int nShift, int bAllPartyMembers=TRUE);
  
  // Do nothing for fSeconds seconds.
  void ActionWait(float fSeconds);
  
  // Set the transition bitmap of a player; this should only be called in area
  // transition scripts. This action should be run by the person "clicking" the
  // area transition via AssignCommand.
  // - nPredefinedAreaTransition:
  //   -> To use a predefined area transition bitmap, use one of AREA_TRANSITION_*
  //   -> To use a custom, user-defined area transition bitmap, use
  //      AREA_TRANSITION_USER_DEFINED and specify the filename in the second
***************
*** 10474,10485 ****
  // Change the portrait of oTarget to use the Portrait ResRef specified.
  // - oTarget: the object for which you are changing the portrait.
  // - sPortraitResRef: The ResRef of the new portrait to use. 
  //                    The ResRef should not include any trailing size letter ( e.g. po_el_f_09_ ).
  // Note: Not all portrait ResRefs are suitable for use with all object types.
  //       Setting the portrait ResRef will also cause the portrait Id
  //       to be set to PORTRAIT_INVALID.
  void SetPortraitResRef(object oTarget, string sPortraitResRef);
  
  // Set oPlaceable's useable object status.
  // Note: Only works on non-static placeables.
! void SetUseableFlag(object oPlaceable, int nUseableFlag);
--- 10659,10776 ----
  // Change the portrait of oTarget to use the Portrait ResRef specified.
  // - oTarget: the object for which you are changing the portrait.
  // - sPortraitResRef: The ResRef of the new portrait to use. 
  //                    The ResRef should not include any trailing size letter ( e.g. po_el_f_09_ ).
  // Note: Not all portrait ResRefs are suitable for use with all object types.
  //       Setting the portrait ResRef will also cause the portrait Id
  //       to be set to PORTRAIT_INVALID.
  void SetPortraitResRef(object oTarget, string sPortraitResRef);
  
  // Set oPlaceable's useable object status.
  // Note: Only works on non-static placeables.
! void SetUseableFlag(object oPlaceable, int nUseableFlag);
! 
! // Get the description of oObject.
! // - oObject: the object from which you are obtaining the description. 
! //            Can be a creature, item, placeable, door, trigger or module object.
! // - bOriginalDescription:  if set to true any new description specified via a SetDescription scripting command
! //                   is ignored and the original object's description is returned instead.
! // - bIdentified: If oObject is an item, setting this to TRUE will return the identified description,
! //                setting this to FALSE will return the unidentified description. This flag has no
! //                effect on objects other than items.
! string GetDescription(object oObject, int bOriginalDescription=FALSE, int bIdentifiedDescription=TRUE);
! 
! // Set the description of oObject.
! // - oObject: the object for which you are changing the description 
! //            Can be a creature, placeable, item, door, or trigger.
! // - sNewDescription: the new description that the object will use.
! // - bIdentified: If oObject is an item, setting this to TRUE will set the identified description,
! //                setting this to FALSE will set the unidentified description. This flag has no
! //                effect on objects other than items.
! // Note: Setting an object's description to "" will make the object
! //       revert to using the description it originally had before any
! //       SetDescription() calls were made on the object.
! void SetDescription(object oObject, string sNewDescription="", int bIdentifiedDescription=TRUE);
! 
! // Get the PC that sent the last player chat(text) message.
! // Should only be called from a module's OnPlayerChat event script.
! // * Returns OBJECT_INVALID on error.
! // Note: Private tells do not trigger a OnPlayerChat event.
! object GetPCChatSpeaker();
! 
! // Get the last player chat(text) message that was sent.
! // Should only be called from a module's OnPlayerChat event script.
! // * Returns empty string "" on error.
! // Note: Private tells do not trigger a OnPlayerChat event.
! string GetPCChatMessage();
! 
! // Get the volume of the last player chat(text) message that was sent.
! // Returns one of the following TALKVOLUME_* constants based on the volume setting
! // that the player used to send the chat message.
! //                TALKVOLUME_TALK
! //                TALKVOLUME_WHISPER
! //                TALKVOLUME_SHOUT
! //                TALKVOLUME_SILENT_SHOUT (used for DM chat channel)
! //                TALKVOLUME_PARTY
! // Should only be called from a module's OnPlayerChat event script.
! // * Returns -1 on error.
! // Note: Private tells do not trigger a OnPlayerChat event.
! int GetPCChatVolume();
! 
! // Set the last player chat(text) message before it gets sent to other players.
! // - sNewChatMessage: The new chat text to be sent onto other players.
! //                    Setting the player chat message to an empty string "",
! //                    will cause the chat message to be discarded 
! //                    (i.e. it will not be sent to other players).
! // Note: The new chat message gets sent after the OnPlayerChat script exits.
! void SetPCChatMessage(string sNewChatMessage="");
! 
! // Set the last player chat(text) volume before it gets sent to other players.
! // - nTalkVolume: The new volume of the chat text to be sent onto other players.
! //                TALKVOLUME_TALK
! //                TALKVOLUME_WHISPER
! //                TALKVOLUME_SHOUT
! //                TALKVOLUME_SILENT_SHOUT (used for DM chat channel)
! //                TALKVOLUME_PARTY
! //                TALKVOLUME_TELL (sends the chat message privately back to the original speaker)
! // Note: The new chat message gets sent after the OnPlayerChat script exits.
! void SetPCChatVolume(int nTalkVolume=TALKVOLUME_TALK);
! 
! // Get the Color of oObject from the color channel specified.
! // - oObject: the object from which you are obtaining the color. 
! //            Can be a creature that has color information (i.e. the playable races).
! // - nColorChannel: The color channel that you want to get the color value of.
! //                   COLOR_CHANNEL_SKIN
! //                   COLOR_CHANNEL_HAIR
! //                   COLOR_CHANNEL_TATTOO_1
! //                   COLOR_CHANNEL_TATTOO_2
! // * Returns -1 on error.
! int GetColor(object oObject, int nColorChannel);
! 
! // Set the color channel of oObject to the color specified.
! // - oObject: the object for which you are changing the color.
! //            Can be a creature that has color information (i.e. the playable races).
! // - nColorChannel: The color channel that you want to set the color value of.
! //                   COLOR_CHANNEL_SKIN
! //                   COLOR_CHANNEL_HAIR
! //                   COLOR_CHANNEL_TATTOO_1
! //                   COLOR_CHANNEL_TATTOO_2
! // - nColorValue: The color you want to set (0-175).
! void SetColor(object oObject, int nColorChannel, int nColorValue);
! 
! // Returns Item property Material.  You need to specify the Material Type.
! // - nMasterialType: The Material Type should be a positive integer between 0 and 77 (see iprp_matcost.2da).
! // Note: The Material Type property will only affect the cost of the item if you modify the cost in the iprp_matcost.2da.
! itemproperty ItemPropertyMaterial(int nMaterialType);
! 
! // Returns Item property Quality. You need to specify the Quality.
! // - nQuality:  The Quality of the item property to create (see iprp_qualcost.2da).
! //              IP_CONST_QUALITY_*
! // Note: The quality property will only affect the cost of the item if you modify the cost in the iprp_qualcost.2da.
! itemproperty ItemPropertyQuality(int nQuality);
! 
! // Returns a generic Additional Item property. You need to specify the Additional property.
! // - nProperty: The item property to create (see iprp_addcost.2da).
! //              IP_CONST_ADDITIONAL_*
! // Note: The additional property only affects the cost of the item if you modify the cost in the iprp_addcost.2da.
! itemproperty ItemPropertyAdditional(int nAdditionalProperty);
! 
*** x0_ch_hen_combat.nss	Mon Aug 04 20:20:45 2008 ***not in prc***
--- x0_ch_hen_combat.nss	Mon Aug 04 20:18:14 2008
***************
*** 2,27 ****
--- 2,39 ----
  //:: Associate: End of Combat End
  //:: NW_CH_AC3
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Calls the end of combat script every round
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Oct 16, 2001
  //:://////////////////////////////////////////////
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: Jan 16th, 2008
+ //:: Added Support for Mounted Combat Feat Support
+ //:://////////////////////////////////////////////
  #include "x0_inc_henai"
  
  void main()
  {
+     if (!GetLocalInt(GetModule(),"X3_NO_MOUNTED_COMBAT_FEAT"))
+         { // set variables on target for mounted combat
+             DeleteLocalInt(OBJECT_SELF,"bX3_LAST_ATTACK_PHYSICAL");
+             DeleteLocalInt(OBJECT_SELF,"nX3_HP_BEFORE");
+             DeleteLocalInt(OBJECT_SELF,"bX3_ALREADY_MOUNTED_COMBAT");
+         } // set variables on target for mounted combat
+ 
      if(!GetSpawnInCondition(NW_FLAG_SET_WARNINGS))
      {
         HenchmenCombatRound(OBJECT_INVALID);
      }
  
  
  
      if(GetSpawnInCondition(NW_FLAG_END_COMBAT_ROUND_EVENT))
      {
          SignalEvent(OBJECT_SELF, EventUserDefined(1003));
      }
*** x0_ch_hen_death.nss	Mon Aug 04 20:20:45 2008 ***not in prc***
--- x0_ch_hen_death.nss	Mon Aug 04 20:18:14 2008
***************
*** 3,29 ****
--- 3,42 ----
  //:: Copyright (c) 2002 Floodgate Entertainment
  //:://////////////////////////////////////////////////
  /*
    OnDeath handler for henchmen ONLY. Causes them to respawn at
    (in order of preference) the respawn point of their master
    or their own starting location.
   */
  //:://////////////////////////////////////////////////
  //:: Created By: Naomi Novik
  //:: Created On: 10/09/2002
  //:://////////////////////////////////////////////////
+ //:://////////////////////////////////////////////////
+ //:: Modified By: Bob Minors
+ //:: Modified On: Jan 12th, 2008
+ //:: Added Support for Dying While Mounted
+ //:: Modified By: Deva Winblood
+ //:: Modified On: April 17th, 2008
+ //:: Fixes for henchmen mounts being lost
+ //:://///////////////////////////////////////////////
  
  #include "x0_i0_henchman"
+ #include "x3_inc_horse"
  
  void main()
  {
+     SetLocalString(OBJECT_SELF,"sX3_DEATH_SCRIPT","x0_ch_hen_death");
+     if (HorseHandleDeath()) return;
+     DeleteLocalString(OBJECT_SELF,"sX3_DEATH_SCRIPT");
+ 
      // Handle a bunch of stuff to keep us from running around,
      // dying again, etc.
      PreRespawnSetup();
  
      // Call for healing
      DelayCommand(0.5, VoiceHealMe(TRUE));
  
      // Get our last master
      object oPC = GetLastMaster();
      object oSelf = OBJECT_SELF;
  
*** x0_i0_spells.nss	Mon Aug 04 20:22:29 2008 *** modified prc script ***
--- x0_i0_spells.nss	Mon Aug 04 20:18:14 2008
***************
*** 678,700 ****
         */
      int nEnemies = 0;
  
      oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_GARGANTUAN, lTarget, TRUE, OBJECT_TYPE_CREATURE);
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while (GetIsObjectValid(oTarget) )
      {
          // * caster cannot be harmed by this spell
          if (spellsIsTarget(oTarget, SPELL_TARGET_SELECTIVEHOSTILE, OBJECT_SELF) && (oTarget != OBJECT_SELF))
          {
              // GZ: You can only fire missiles on visible targets
!             if (GetObjectSeen(oTarget,OBJECT_SELF))
              {
                  nEnemies++;
              }
          }
          oTarget = GetNextObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_GARGANTUAN, lTarget, TRUE, OBJECT_TYPE_CREATURE);
       }
  
       if (nEnemies == 0) return; // * Exit if no enemies to hit
       int nExtraMissiles = nMissiles / nEnemies;
  
       // April 2003
--- 678,703 ----
         */
      int nEnemies = 0;
  
      oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_GARGANTUAN, lTarget, TRUE, OBJECT_TYPE_CREATURE);
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while (GetIsObjectValid(oTarget) )
      {
          // * caster cannot be harmed by this spell
          if (spellsIsTarget(oTarget, SPELL_TARGET_SELECTIVEHOSTILE, OBJECT_SELF) && (oTarget != OBJECT_SELF))
          {
              // GZ: You can only fire missiles on visible targets
!             // If the firing object is a placeable (such as a projectile trap),
!             // we skip the line of sight check as placeables can't "see" things.
!             if ( ( GetObjectType(OBJECT_SELF) == OBJECT_TYPE_PLACEABLE ) ||
!                    GetObjectSeen(oTarget,OBJECT_SELF))
              {
                  nEnemies++;
              }
          }
          oTarget = GetNextObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_GARGANTUAN, lTarget, TRUE, OBJECT_TYPE_CREATURE);
       }
  
       if (nEnemies == 0) return; // * Exit if no enemies to hit
       int nExtraMissiles = nMissiles / nEnemies;
  
       // April 2003
***************
*** 711,733 ****
       if (nExtraMissiles >0)
          nRemainder = nMissiles % nEnemies;
  
       if (nEnemies > nMissiles)
          nEnemies = nMissiles;
  
      oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_GARGANTUAN, lTarget, TRUE, OBJECT_TYPE_CREATURE);
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while (GetIsObjectValid(oTarget) && nCnt <= nEnemies)
      {
          // * caster cannot be harmed by this spell
!         if (spellsIsTarget(oTarget, SPELL_TARGET_SELECTIVEHOSTILE, OBJECT_SELF) && (oTarget != OBJECT_SELF) && (GetObjectSeen(oTarget,OBJECT_SELF)))
          {
                  //Fire cast spell at event for the specified target
                  SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, nSpell));
  
                  // * recalculate appropriate distances
                  fDist = GetDistanceBetween(OBJECT_SELF, oTarget);
                  fDelay = fDist/(3.0 * log(fDist) + 2.0);
  
                  // Firebrand.
                  // It means that once the target has taken damage this round from the
                  // spell it won't take subsequent damage
--- 714,739 ----
       if (nExtraMissiles >0)
          nRemainder = nMissiles % nEnemies;
  
       if (nEnemies > nMissiles)
          nEnemies = nMissiles;
  
      oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_GARGANTUAN, lTarget, TRUE, OBJECT_TYPE_CREATURE);
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while (GetIsObjectValid(oTarget) && nCnt <= nEnemies)
      {
          // * caster cannot be harmed by this spell
!         if (spellsIsTarget(oTarget, SPELL_TARGET_SELECTIVEHOSTILE, OBJECT_SELF) &&
!            (oTarget != OBJECT_SELF) &&
!            (( GetObjectType(OBJECT_SELF) == OBJECT_TYPE_PLACEABLE ) ||
!            (GetObjectSeen(oTarget,OBJECT_SELF))))
          {
                  //Fire cast spell at event for the specified target
                  SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, nSpell));
  
                  // * recalculate appropriate distances
                  fDist = GetDistanceBetween(OBJECT_SELF, oTarget);
                  fDelay = fDist/(3.0 * log(fDist) + 2.0);
  
                  // Firebrand.
                  // It means that once the target has taken damage this round from the
                  // spell it won't take subsequent damage
***************
*** 926,989 ****
--- 932,1009 ----
  
  int CanCreatureBeDestroyed(object oTarget)
  {
      if (GetPlotFlag(oTarget) == FALSE && GetImmortal(oTarget) == FALSE)
      {
          return TRUE;
      }
      return FALSE;
  }
  
  //*GZ: 2003-07-23. honor critical and weapon spec
+ // Updated: 02/14/2008 CraigW - Added support for Epic Weapon Specialization.
  // nCrit -
  
  int ArcaneArcherDamageDoneByBow(int bCrit = FALSE, object oUser = OBJECT_SELF)
  {
      object oItem = GetItemInSlot(INVENTORY_SLOT_RIGHTHAND);
      int nDamage;
      int bSpec = FALSE;
+     int bEpicSpecialization = FALSE;
  
      if (GetIsObjectValid(oItem) == TRUE)
      {
          if (GetBaseItemType(oItem) == BASE_ITEM_LONGBOW )
          {
              nDamage = d8();
              if (GetHasFeat(FEAT_WEAPON_SPECIALIZATION_LONGBOW,oUser))
              {
                bSpec = TRUE;
              }
+             if (GetHasFeat(FEAT_EPIC_WEAPON_SPECIALIZATION_LONGBOW,oUser))
+             {
+               bEpicSpecialization = TRUE;
+             }
          }
          else
          if (GetBaseItemType(oItem) == BASE_ITEM_SHORTBOW)
          {
              nDamage = d6();
              if (GetHasFeat(FEAT_WEAPON_SPECIALIZATION_SHORTBOW,oUser))
              {
                bSpec = TRUE;
              }
+             if (GetHasFeat(FEAT_EPIC_WEAPON_SPECIALIZATION_SHORTBOW,oUser))
+             {
+               bEpicSpecialization = TRUE;
+             }
          }
          else
              return 0;
      }
      else
      {
              return 0;
      }
  
      // add strength bonus
      int nStrength = GetAbilityModifier(ABILITY_STRENGTH,oUser);
      nDamage += nStrength;
  
      if (bSpec == TRUE)
      {
          nDamage +=2;
+     }
+     if ( bEpicSpecialization == TRUE )
+     {
+         nDamage +=4;
      }
      if (bCrit == TRUE)
      {
           nDamage *=3;
      }
  
      return nDamage;
  }
  
  //*GZ: 2003-07-23. Properly calculated enhancement bonus
  int ArcaneArcherCalculateBonus()
*** x0_inc_henai.nss	Mon Aug 04 20:22:29 2008 **not in prc***
--- x0_inc_henai.nss	Mon Aug 04 20:18:14 2008
***************
*** 26,47 ****
--- 26,50 ----
  
      -=-=-=-=-=-=-
      MODIFICATIONS
      -=-=-=-=-=-=-
  
  
  
      // * BK Feb 6 2003
      // * Put a check in so that when a henchmen who cannot disarm a trap
      // * sees a trap they do not repeat their voiceover forever
  
+     // * Deva Winblood    Feb 22nd, 2008
+     // * Made the Open Inventory Radial work with horses with Saddlebags
+ 
  
  */
  //:://////////////////////////////////////////////
  //:: Created By:
  //:: Created On:
  //:://////////////////////////////////////////////
  
  // #include "nw_i0_generic"  //...and through this also x0_inc_generic
  
  #include "x0_i0_henchman"
  
***************
*** 670,693 ****
          }
          else
          if (GetLocalInt(OBJECT_SELF, "X2_L_STOPCASTING") == 0)
          {
           //   SpeakString("Was in casting mode. Switching to NO cast mode");
              SetLocalInt(OBJECT_SELF, "X2_L_STOPCASTING", 10);
              VoiceCanDo();
          }
        break;
      }
      case ASSOCIATE_COMMAND_INVENTORY:
          // feb 18. You are now allowed to access inventory during combat.
!          if (nBanInventory == TRUE)
          {
              SpeakStringByStrRef(9066);
          }
          else
          {
              // * cannot modify disabled equipment
              if (GetLocalInt(OBJECT_SELF, "X2_JUST_A_DISABLEEQUIP") == FALSE)
              {
                  OpenInventory(OBJECT_SELF, oShouter);
              }
              else
--- 673,700 ----
          }
          else
          if (GetLocalInt(OBJECT_SELF, "X2_L_STOPCASTING") == 0)
          {
           //   SpeakString("Was in casting mode. Switching to NO cast mode");
              SetLocalInt(OBJECT_SELF, "X2_L_STOPCASTING", 10);
              VoiceCanDo();
          }
        break;
      }
      case ASSOCIATE_COMMAND_INVENTORY:
+         if (GetLocalInt(OBJECT_SELF,"bX3_HAS_SADDLEBAGS")&&GetLocalInt(GetModule(),"X3_HORSE_ENABLE_SADDLEBAGS")&&GetMaster(OBJECT_SELF)==oShouter)
+         { // open horse saddlebags
+             OpenInventory(OBJECT_SELF, oShouter);
+         } // open horse saddlebags
          // feb 18. You are now allowed to access inventory during combat.
!         else if (nBanInventory == TRUE)
          {
              SpeakStringByStrRef(9066);
          }
          else
          {
              // * cannot modify disabled equipment
              if (GetLocalInt(OBJECT_SELF, "X2_JUST_A_DISABLEEQUIP") == FALSE)
              {
                  OpenInventory(OBJECT_SELF, oShouter);
              }
              else
*** x0_s0_gustwind.nss	Mon Aug 04 20:20:59 2008 *** prc script modified ***
--- x0_s0_gustwind.nss	Mon Aug 04 20:18:14 2008
***************
*** 34,55 ****
--- 34,56 ----
  
      if (!X2PreSpellCastCode())
      {
      // If code within the PreSpellCastHook (i.e. UMD) reports FALSE, do not run this spell
          return;
      }
  
  // End of Spell Cast Hook
  
  
      //Declare major variables
+     string sAOETag;
      object oCaster = OBJECT_SELF;
      int nCasterLvl = GetCasterLevel(oCaster);
      int nMetaMagic = GetMetaMagicFeat();
      int nDamage;
      float fDelay;
      effect eExplode = EffectVisualEffect(VFX_FNF_LOS_NORMAL_20);
      effect eVis = EffectVisualEffect(VFX_IMP_PULSE_WIND);
     // effect eDam;
      //Get the spell target location as opposed to the spell target.
      location lTarget = GetSpellTargetLocation();
  
***************
*** 58,81 ****
--- 59,93 ----
  
  
      //Declare the spell shape, size and the location.  Capture the first target object in the shape.
      object oTarget = GetFirstObjectInShape(SHAPE_SPHERE, RADIUS_SIZE_HUGE, lTarget, TRUE, OBJECT_TYPE_CREATURE | OBJECT_TYPE_DOOR | OBJECT_TYPE_PLACEABLE | OBJECT_TYPE_AREA_OF_EFFECT);
  
  
      //Cycle through the targets within the spell shape until an invalid object is captured.
      while (GetIsObjectValid(oTarget))
      {
          if (GetObjectType(oTarget) == OBJECT_TYPE_AREA_OF_EFFECT)
          {
+             // Gust of wind should only destroy "cloud/fog like" area of effect spells.
+             sAOETag = GetTag(oTarget);
+             if ( sAOETag == "VFX_PER_FOGACID" ||
+                  sAOETag == "VFX_PER_FOGKILL" ||
+                  sAOETag == "VFX_PER_FOGBEWILDERMENT" ||
+                  sAOETag == "VFX_PER_FOGSTINK" ||
+                  sAOETag == "VFX_PER_FOGFIRE" ||
+                  sAOETag == "VFX_PER_FOGMIND" ||
+                  sAOETag == "VFX_PER_CREEPING_DOOM")
+             {
                  DestroyObject(oTarget);
              }
+         }
          else
          if (spellsIsTarget(oTarget, SPELL_TARGET_STANDARDHOSTILE, OBJECT_SELF))
          {
              {
                  //Fire cast spell at event for the specified target
                  SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, GetSpellId()));
                  //Get the distance between the explosion and the target to calculate delay
                  fDelay = GetDistanceBetweenLocations(lTarget, GetLocation(oTarget))/20;
  
                  // * unlocked doors will reverse their open state
                  if (GetObjectType(oTarget) == OBJECT_TYPE_DOOR)
*** x0_s0_udetfoe.nss	Mon Aug 04 20:21:01 2008 *** modified prc script***
--- x0_s0_udetfoe.nss	Mon Aug 04 20:18:14 2008
***************
*** 19,41 ****
  #include "x2_inc_spellhook"
  
  void GrantProtection(object oTarget)
  {
      effect eVis = EffectVisualEffect(VFX_IMP_HOLY_AID);
  
      effect eNeg = EffectDamageImmunityIncrease(DAMAGE_TYPE_NEGATIVE, 100);
      effect eLevel = EffectImmunity(IMMUNITY_TYPE_NEGATIVE_LEVEL);
      effect eAbil = EffectImmunity(IMMUNITY_TYPE_ABILITY_DECREASE);
      effect ePoison = EffectImmunity(IMMUNITY_TYPE_POISON);
      effect eDisease = EffectImmunity(IMMUNITY_TYPE_DISEASE);
!     effect eAC = EffectACIncrease(4);
  
      int nDuration = GetCasterLevel(OBJECT_SELF);
      int nMetaMagic = GetMetaMagicFeat();
  
      //Enter Metamagic conditions
      if (nMetaMagic == METAMAGIC_EXTEND)
      {
          nDuration = nDuration *2; //Duration is +100%
      }
  
      //Link Effects
--- 19,41 ----
  #include "x2_inc_spellhook"
  
  void GrantProtection(object oTarget)
  {
      effect eVis = EffectVisualEffect(VFX_IMP_HOLY_AID);
  
      effect eNeg = EffectDamageImmunityIncrease(DAMAGE_TYPE_NEGATIVE, 100);
      effect eLevel = EffectImmunity(IMMUNITY_TYPE_NEGATIVE_LEVEL);
      effect eAbil = EffectImmunity(IMMUNITY_TYPE_ABILITY_DECREASE);
      effect ePoison = EffectImmunity(IMMUNITY_TYPE_POISON);
      effect eDisease = EffectImmunity(IMMUNITY_TYPE_DISEASE);
!     effect eAC = EffectACIncrease(4,AC_DEFLECTION_BONUS);
  
      int nDuration = GetCasterLevel(OBJECT_SELF);
      int nMetaMagic = GetMetaMagicFeat();
  
      //Enter Metamagic conditions
      if (nMetaMagic == METAMAGIC_EXTEND)
      {
          nDuration = nDuration *2; //Duration is +100%
      }
  
      //Link Effects
*** x0_s2_harpsmile.nss	Mon Aug 04 20:21:02 2008 *** not in prc***
--- x0_s2_harpsmile.nss	Mon Aug 04 20:18:14 2008
***************
*** 16,38 ****
  //                            Epic Level progession
  //:://////////////////////////////////////////////
  #include "nw_i0_spells"
  
  void main()
  {
      //Declare major variables
      object oTarget = GetSpellTargetObject();
      int nDuration = 5;
      int nAmount = 2;
      // epic level progression
!     int nLevel = GetLevelByClass(CLASS_TYPE_DIVINECHAMPION,oTarget)  ;
      int nLevelB = (nLevel / 3)-1;
      if (nLevelB <0)
      {
          nLevelB =0;
      }
      nAmount += (nLevelB*2); // +2 to saves every 3 levels past 3
  
  
      effect eSaving =  EffectSavingThrowIncrease(SAVING_THROW_ALL, nAmount, SAVING_THROW_TYPE_ALL);
      effect eDur = EffectVisualEffect(VFX_DUR_PROTECTION_ELEMENTS);
      effect eVis = EffectVisualEffect(VFX_IMP_ELEMENTAL_PROTECTION);
--- 16,38 ----
  //                            Epic Level progession
  //:://////////////////////////////////////////////
  #include "nw_i0_spells"
  
  void main()
  {
      //Declare major variables
      object oTarget = GetSpellTargetObject();
      int nDuration = 5;
      int nAmount = 2;
      // epic level progression
!     int nLevel = GetLevelByClass(CLASS_TYPE_HARPER,oTarget)  ;
      int nLevelB = (nLevel / 3)-1;
      if (nLevelB <0)
      {
          nLevelB =0;
      }
      nAmount += (nLevelB*2); // +2 to saves every 3 levels past 3
  
  
      effect eSaving =  EffectSavingThrowIncrease(SAVING_THROW_ALL, nAmount, SAVING_THROW_TYPE_ALL);
      effect eDur = EffectVisualEffect(VFX_DUR_PROTECTION_ELEMENTS);
      effect eVis = EffectVisualEffect(VFX_IMP_ELEMENTAL_PROTECTION);
*** x1_s1_eyebray.nss	Mon Aug 04 20:22:29 2008 *** not in prc***
--- x1_s1_eyebray.nss	Mon Aug 04 20:18:14 2008
***************
*** 22,46 ****
      int nLevel = GetHitDice(OBJECT_SELF);
      int nCount = nLevel /5;
      if (nCount == 0)
      {
          nCount =1;
      }
  
      int nDamage;
  
      switch (nSpell)
      {
!         case 710:  nDamage = d4(nCount) + (nLevel /2);
!         case 711:  nDamage = d6(2) + (nCount*2);
!         case 712:  nDamage = d6(nCount) + (nCount);
      }
  
      return nDamage;
  }
  
  #include "NW_I0_SPELLS"
  void main()
  {
      //Declare major variables
      object oTarget = GetSpellTargetObject();
      int nHD = GetHitDice(OBJECT_SELF);
--- 22,52 ----
      int nLevel = GetHitDice(OBJECT_SELF);
      int nCount = nLevel /5;
      if (nCount == 0)
      {
          nCount =1;
      }
  
      int nDamage;
  
      switch (nSpell)
      {
!         case 710:
!             nDamage = d4(nCount) + (nLevel /2);
!             break;
!         case 711:
!             nDamage = d6(2) + (nCount*2);
!             break;
!         case 712:
!             nDamage = d6(nCount) + (nCount);
!             break;
      }
  
      return nDamage;
  }
  
  #include "NW_I0_SPELLS"
  void main()
  {
      //Declare major variables
      object oTarget = GetSpellTargetObject();
      int nHD = GetHitDice(OBJECT_SELF);
*** x2_ch_summon_sld.nss	Mon Aug 04 20:21:09 2008 *** not in prc***
--- x2_ch_summon_sld.nss	Mon Aug 04 20:18:14 2008
***************
*** 15,41 ****
  //:://////////////////////////////////////////////
  //:: Created By: Georg Zoeller
  //:: Created On: 2003-07-24
  //:://////////////////////////////////////////////
  
  #include "X0_INC_HENAI"
  #include "X2_INC_SUMMSCALE"
  
  
  void DoScaleESL(object oSelf)
  {
!     if (GetStringLowerCase(GetTag(OBJECT_SELF))== "x2_s_eshadlord")
      {
          SSMScaleEpicShadowLord(oSelf);
      }
!     else if (GetStringLowerCase(GetTag(OBJECT_SELF))== "x2_s_vrock")
      {
          SSMScaleEpicFiendishServant(oSelf);
      }
  }
  void main()
  {
      //Sets up the special henchmen listening patterns
      SetAssociateListenPatterns();
  
      // Set additional henchman listening patterns
      bkSetListeningPatterns();
--- 15,49 ----
  //:://////////////////////////////////////////////
  //:: Created By: Georg Zoeller
  //:: Created On: 2003-07-24
  //:://////////////////////////////////////////////
  
  #include "X0_INC_HENAI"
  #include "X2_INC_SUMMSCALE"
  
  
  void DoScaleESL(object oSelf)
  {
!     if (GetStringLowerCase(GetTag(oSelf))== "x2_s_eshadlord")
      {
          SSMScaleEpicShadowLord(oSelf);
+ 
+         // Epic Shadow Lord is incorporeal and gets a concealment bonus.
+         effect eConceal = EffectConcealment(50, MISS_CHANCE_TYPE_NORMAL);
+         eConceal = ExtraordinaryEffect(eConceal);
+         effect eGhost = EffectCutsceneGhost();
+         eGhost = ExtraordinaryEffect(eGhost);
+         ApplyEffectToObject(DURATION_TYPE_PERMANENT, eConceal, oSelf);
+         ApplyEffectToObject(DURATION_TYPE_PERMANENT, eGhost, oSelf);
      }
!     else if (GetStringLowerCase(GetTag(oSelf))== "x2_s_vrock")
      {
          SSMScaleEpicFiendishServant(oSelf);
      }
  }
  void main()
  {
      //Sets up the special henchmen listening patterns
      SetAssociateListenPatterns();
  
      // Set additional henchman listening patterns
      bkSetListeningPatterns();
*** x2_def_spawn.nss	Mon Aug 04 20:21:22 2008 *** not in prc ***
--- x2_def_spawn.nss	Mon Aug 04 20:18:14 2008
***************
*** 9,51 ****
--- 9,82 ----
      2003-07-28: Georg Zoeller:
  
      If you set a ninteger on the creature named
      "X2_USERDEFINED_ONSPAWN_EVENTS"
      The creature will fire a pre and a post-spawn
      event on itself, depending on the value of that
      variable
      1 - Fire Userdefined Event 1510 (pre spawn)
      2 - Fire Userdefined Event 1511 (post spawn)
      3 - Fire both events
  
+     2007-12-31: Deva Winblood
+     Modified to look for X3_HORSE_OWNER_TAG and if
+     it is defined look for an NPC with that tag
+     nearby or in the module (checks near first).
+     It will make that NPC this horse's master.
+ 
  */
  //:://////////////////////////////////////////////
  //:: Created By: Keith Warner, Georg Zoeller
  //:: Created On: June 11/03
  //:://////////////////////////////////////////////
  
  const int EVENT_USER_DEFINED_PRESPAWN = 1510;
  const int EVENT_USER_DEFINED_POSTSPAWN = 1511;
  
  
  #include "x2_inc_switches"
  void main()
  {
+     string sTag;
+     object oNPC;
      // User defined OnSpawn event requested?
      int nSpecEvent = GetLocalInt(OBJECT_SELF,"X2_USERDEFINED_ONSPAWN_EVENTS");
  
+ 
      // Pre Spawn Event requested
      if (nSpecEvent == 1  || nSpecEvent == 3  )
      {
      SignalEvent(OBJECT_SELF,EventUserDefined(EVENT_USER_DEFINED_PRESPAWN ));
      }
+ 
+     sTag=GetLocalString(OBJECT_SELF,"X3_HORSE_OWNER_TAG");
+     if (GetStringLength(sTag)>0)
+     { // look for master
+         oNPC=GetNearestObjectByTag(sTag);
+         if (GetIsObjectValid(oNPC)&&GetObjectType(oNPC)==OBJECT_TYPE_CREATURE)
+         { // master found
+             AddHenchman(oNPC);
+         } // master found
+         else
+         { // look in module
+             oNPC=GetObjectByTag(sTag);
+             if (GetIsObjectValid(oNPC)&&GetObjectType(oNPC)==OBJECT_TYPE_CREATURE)
+             { // master found
+                 AddHenchman(oNPC);
+             } // master found
+             else
+             { // master does not exist - remove X3_HORSE_OWNER_TAG
+                 DeleteLocalString(OBJECT_SELF,"X3_HORSE_OWNER_TAG");
+             } // master does not exist - remove X3_HORSE_OWNER_TAG
+         } // look in module
+     } // look for master
  
      /*  Fix for the new golems to reduce their number of attacks */
  
      int nNumber = GetLocalInt(OBJECT_SELF,CREATURE_VAR_NUMBER_OF_ATTACKS);
      if (nNumber >0 )
      {
          SetBaseAttackBonus(nNumber);
      }
  
      // Execute default OnSpawn script.
      ExecuteScript("nw_c2_default9", OBJECT_SELF);
*** x2_hen_death.nss	Mon Aug 04 20:22:29 2008 *** not in prc***
--- x2_hen_death.nss	Mon Aug 04 20:18:14 2008
***************
*** 1,15 ****
  //::///////////////////////////////////////////////
  //:: Henchman Death Script
  //::
! //:: NW_CH_AC7.nss
  //::
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  //:: <description>
  //:://////////////////////////////////////////////
  //::
  //:: Created By:
  //:: Modified by:   Brent, April 3 2002
  //::                Removed delay in respawning
  //::                the henchman - caused bugs
  //:: Modified November 14 2002
--- 1,15 ----
  //::///////////////////////////////////////////////
  //:: Henchman Death Script
  //::
! //:: X2_HEN_DEATH.nss
  //::
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  //:: <description>
  //:://////////////////////////////////////////////
  //::
  //:: Created By:
  //:: Modified by:   Brent, April 3 2002
  //::                Removed delay in respawning
  //::                the henchman - caused bugs
  //:: Modified November 14 2002
***************
*** 25,58 ****
      Removes all negative effects of a temporary nature
      and all permanent effects of a supernatural nature
      from the character. Does not remove the effects
      relating to Mind-Affecting spells or movement alteration.
      Heals target for 5d8 + 1 point per caster level.
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Jan 7, 2002
  //:://////////////////////////////////////////////
  //:: VFX Pass By: Preston W, On: June 20, 2001
  #include "nw_i0_generic"
  #include "nw_i0_plot"
  #include "x0_i0_henchman"
! 
  
  void main()
  {
!     // * This is used by the advanced henchmen
!     // * Let Brent know if it interferes with animal
!     // * companions et cetera
! 
! 
  
      if (GetAssociateType(OBJECT_SELF) == ASSOCIATE_TYPE_HENCHMAN)
      {
         SetLocalInt(OBJECT_SELF, "X2_L_IJUSTDIED", 10);
         SetKilled(GetMaster());
         SetDidDie();
         object oHench = OBJECT_SELF;
          // * Take them out of stealth mode too (Nov 1 - BK)
          SetActionMode(oHench, ACTION_MODE_STEALTH, FALSE);
          // * Remove invisibility type effects off of henchmen (Nov 7 - BK)
          RemoveSpellEffects(SPELL_INVISIBILITY, oHench, oHench);
--- 25,58 ----
      Removes all negative effects of a temporary nature
      and all permanent effects of a supernatural nature
      from the character. Does not remove the effects
      relating to Mind-Affecting spells or movement alteration.
      Heals target for 5d8 + 1 point per caster level.
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Jan 7, 2002
  //:://////////////////////////////////////////////
  //:: VFX Pass By: Preston W, On: June 20, 2001
+ //:: Modifications To Support Horses By: Deva Winblood, On: April 17th, 2008
+ 
  #include "nw_i0_generic"
  #include "nw_i0_plot"
  #include "x0_i0_henchman"
! #include "x3_inc_horse"
  
  void main()
  {
!     SetLocalString(OBJECT_SELF,"sX3_DEATH_SCRIPT","x2_hen_death");
!     if (HorseHandleDeath()) return;
!     DeleteLocalString(OBJECT_SELF,"sX3_DEATH_SCRIPT");
  
      if (GetAssociateType(OBJECT_SELF) == ASSOCIATE_TYPE_HENCHMAN)
      {
         SetLocalInt(OBJECT_SELF, "X2_L_IJUSTDIED", 10);
         SetKilled(GetMaster());
         SetDidDie();
         object oHench = OBJECT_SELF;
          // * Take them out of stealth mode too (Nov 1 - BK)
          SetActionMode(oHench, ACTION_MODE_STEALTH, FALSE);
          // * Remove invisibility type effects off of henchmen (Nov 7 - BK)
          RemoveSpellEffects(SPELL_INVISIBILITY, oHench, oHench);
*** x2_i0_spells.nss	Mon Aug 04 20:22:30 2008 *** modified prc script***
--- x2_i0_spells.nss	Mon Aug 04 20:18:15 2008
***************
*** 196,218 ****
        (nItem == BASE_ITEM_HEAVYFLAIL) ||
        (nItem == BASE_ITEM_LIGHTFLAIL) ||
        (nItem == BASE_ITEM_LIGHTHAMMER) ||
        (nItem == BASE_ITEM_LIGHTMACE) ||
        (nItem == BASE_ITEM_MORNINGSTAR) ||
        (nItem == BASE_ITEM_QUARTERSTAFF) ||
        (nItem == BASE_ITEM_RAPIER) ||
        (nItem == BASE_ITEM_SHORTSPEAR) ||
        (nItem == BASE_ITEM_SHORTSWORD) ||
        (nItem == BASE_ITEM_WARHAMMER)  ||
        (nItem == BASE_ITEM_WHIP)  ||
!       (nItem == BASE_ITEM_DWARVENWARAXE))
     {
          return TRUE;
     }
     return FALSE;
  }
  
  //------------------------------------------------------------------------------
  // AN, 2003
  // Returns TRUE if oItem has any item property that classifies it as magical item
  //------------------------------------------------------------------------------
  int GetIsMagicalItem(object oItem)
--- 196,220 ----
        (nItem == BASE_ITEM_HEAVYFLAIL) ||
        (nItem == BASE_ITEM_LIGHTFLAIL) ||
        (nItem == BASE_ITEM_LIGHTHAMMER) ||
        (nItem == BASE_ITEM_LIGHTMACE) ||
        (nItem == BASE_ITEM_MORNINGSTAR) ||
        (nItem == BASE_ITEM_QUARTERSTAFF) ||
        (nItem == BASE_ITEM_RAPIER) ||
        (nItem == BASE_ITEM_SHORTSPEAR) ||
        (nItem == BASE_ITEM_SHORTSWORD) ||
        (nItem == BASE_ITEM_WARHAMMER)  ||
        (nItem == BASE_ITEM_WHIP)  ||
!       (nItem == BASE_ITEM_DWARVENWARAXE) ||
!       (nItem == BASE_ITEM_MAGICSTAFF) ||
!       (nItem == BASE_ITEM_TRIDENT) )
     {
          return TRUE;
     }
     return FALSE;
  }
  
  //------------------------------------------------------------------------------
  // AN, 2003
  // Returns TRUE if oItem has any item property that classifies it as magical item
  //------------------------------------------------------------------------------
  int GetIsMagicalItem(object oItem)
*** x2_inc_spellhook.nss	Mon Aug 04 20:21:25 2008 ** modified prc script***
--- x2_inc_spellhook.nss	Mon Aug 04 20:18:15 2008
***************
*** 10,34 ****
--- 10,50 ----
  
      If you want to implement material components
      into spells or add restrictions to certain
      spells, this is the place to do it.
  
  */
  //:://////////////////////////////////////////////
  //:: Created By: Georg Zoeller
  //:: Created On: 2003-06-04
  //:: Updated On: 2003-10-25
  //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified Date: January 15th-16th, 2008
+ //:://////////////////////////////////////////////
+ /*
+     Modified to insure no shapeshifting spells are castable upon
+     mounted targets.  This prevents problems that can occur due
+     to dismounting after shape shifting, or other issues that can
+     occur due to preserved appearances getting out of synch.
+ 
+     This can additional check can be disabled by setting the variable
+     X3_NO_SHAPESHIFT_SPELL_CHECK to 1 on the module object.  If this
+     variable is set then this script will function as it did prior to
+     this modification.
+ 
+ */
  
  //#include "x2_inc_itemprop" - Inherited from x2_inc_craft
  #include "x2_inc_craft"
+ #include "x3_inc_horse"
  
  
  const int X2_EVENT_CONCENTRATION_BROKEN = 12400;
  
  
  // Use Magic Device Check.
  // Returns TRUE if the Spell is allowed to be cast, either because the
  // character is allowed to cast it or he has won the required UMD check
  // Only active on spell scroll
  int X2UseMagicDeviceCheck();
  
***************
*** 228,260 ****
--- 244,307 ----
              {
                  SignalEvent(OBJECT_SELF,EventUserDefined(X2_EVENT_CONCENTRATION_BROKEN));
              }
              else if (X2GetBreakConcentrationCondition(oMaster))
              {
                  SignalEvent(OBJECT_SELF,EventUserDefined(X2_EVENT_CONCENTRATION_BROKEN));
              }
           }
      }
  }
  
+ 
+ //------------------------------------------------------------------------------
+ // This function will return TRUE if the spell that is cast is a shape shifting
+ // spell.
+ //------------------------------------------------------------------------------
+ int X3ShapeShiftSpell(object oTarget)
+ { // PURPOSE: Return TRUE if a shape shifting spell was cast at oTarget
+     int nSpellID=GetSpellId();
+     string sUp=GetStringUpperCase(Get2DAString("x3restrict","SHAPESHIFT", nSpellID));
+     if (sUp=="YES") return TRUE;
+     return FALSE;
+ } // X3ShapeShiftSpell()
+ 
+ 
  //------------------------------------------------------------------------------
  // if FALSE is returned by this function, the spell will not be cast
  // the order in which the functions are called here DOES MATTER, changing it
  // WILL break the crafting subsystems
  //------------------------------------------------------------------------------
  int X2PreSpellCastCode()
  {
     object oTarget = GetSpellTargetObject();
     int nContinue;
  
     //---------------------------------------------------------------------------
+    // This small addition will check to see if the target is mounted and the
+    // spell is therefor one that should not be permitted.
+    //---------------------------------------------------------------------------
+    if (!GetLocalInt(GetModule(),"X3_NO_SHAPESHIFT_SPELL_CHECK"))
+    { // do check for abort due to being mounted check
+        if (HorseGetIsMounted(oTarget)&&X3ShapeShiftSpell(oTarget))
+        { // shape shifting not allowed while mounted
+            if(GetIsPC(oTarget))
+            {
+                FloatingTextStrRefOnCreature(111982,oTarget,FALSE);
+            }
+            return FALSE;
+        } // shape shifting not allowed while mounted
+    } // do check for abort due to being mounted check
+ 
+ 
+    //---------------------------------------------------------------------------
     // This stuff is only interesting for player characters we assume that use
     // magic device always works and NPCs don't use the crafting feats or
     // sequencers anyway. Thus, any NON PC spellcaster always exits this script
     // with TRUE (unless they are DM possessed or in the Wild Magic Area in
     // Chapter 2 of Hordes of the Underdark.
     //---------------------------------------------------------------------------
     if (!GetIsPC(OBJECT_SELF))
     {
         if( !GetIsDMPossessed(OBJECT_SELF) && !GetLocalInt(GetArea(OBJECT_SELF), "X2_L_WILD_MAGIC"))
         {
              return TRUE;
*** x2_mod_def_equ.nss	Mon Aug 04 20:21:29 2008 *** not in prc ***
--- x2_mod_def_equ.nss	Mon Aug 04 20:18:15 2008
***************
*** 2,25 ****
--- 2,32 ----
  //:: Example XP2 OnItemEquipped
  //:: x2_mod_def_equ
  //:: (c) 2003 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Put into: OnEquip Event
  */
  //:://////////////////////////////////////////////
  //:: Created By: Georg Zoeller
  //:: Created On: 2003-07-16
  //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: April 15th, 2008
+ //:: Added Support for Mounted Archery Feat penalties
+ //:://////////////////////////////////////////////
+ 
  #include "x2_inc_switches"
  #include "x2_inc_intweapon"
+ #include "x3_inc_horse"
+ 
  void main()
  {
  
      object oItem = GetPCItemLastEquipped();
      object oPC   = GetPCItemLastEquippedBy();
      // -------------------------------------------------------------------------
      // Intelligent Weapon System
      // -------------------------------------------------------------------------
      if (IPGetIsIntelligentWeapon(oItem))
      {
          IWSetIntelligentWeaponEquipped(oPC,oItem);
***************
*** 37,58 ****
--- 44,73 ----
              if (GetLocalInt(oPC,"X2_L_ENSERRIC_ASKED_Q3")==1)
              {
                  ExecuteScript ("x2_ens_dodrain",oPC);
              }
              else
              {
                  IWPlayRandomEquipComment(oPC,oItem);
              }
          }
      }
  
+     // -------------------------------------------------------------------------
+     // Mounted benefits control
+     // -------------------------------------------------------------------------
+     if (GetWeaponRanged(oItem))
+     {
+         SetLocalInt(oPC,"bX3_M_ARCHERY",TRUE);
+         HORSE_SupportAdjustMountedArcheryPenalty(oPC);
+     }
  
      // -------------------------------------------------------------------------
      // Generic Item Script Execution Code
      // If MODULE_SWITCH_EXECUTE_TAGBASED_SCRIPTS is set to TRUE on the module,
      // it will execute a script that has the same name as the item's tag
      // inside this script you can manage scripts for all events by checking against
      // GetUserDefinedItemEventNumber(). See x2_it_example.nss
      // -------------------------------------------------------------------------
      if (GetModuleSwitchValue(MODULE_SWITCH_ENABLE_TAGBASED_SCRIPTS) == TRUE)
      {
          SetUserDefinedItemEventNumber(X2_ITEM_EVENT_EQUIP);
*** x2_mod_def_rest.nss	Mon Aug 04 20:21:29 2008 *** not in prc***
--- x2_mod_def_rest.nss	Mon Aug 04 20:18:15 2008
***************
*** 1,28 ****
--- 1,67 ----
  //::///////////////////////////////////////////////
  //:: Name: x2_onrest
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      The generic wandering monster system
  */
  //:://////////////////////////////////////////////
  //:: Created By: Georg Zoeller
  //:: Created On: June 9/03
  //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified Date: January 28th, 2008
+ //:://////////////////////////////////////////////
  
  #include "x2_inc_restsys"
  #include "x2_inc_switches"
+ #include "x3_inc_horse"
+ 
  void main()
  {
      object oPC = GetLastPCRested();
+     object oMount;
+ 
+     if (!GetLocalInt(GetModule(),"X3_MOUNT_NO_REST_DISMOUNT"))
+     { // make sure not mounted
+         /*  Deva, Jan 17, 2008
+             Do not allow a mounted PC to rest
+         */
+         if (HorseGetIsMounted(oPC))
+         { // cannot mount
+             if (GetLocalInt(oPC,"X3_REST_CANCEL_MESSAGE_SENT"))
+             { // cancel message already played
+                 DeleteLocalInt(oPC,"X3_REST_CANCEL_MESSAGE_SENT");
+             } // cancel message already played
+             else
+             { // play cancel message
+                 FloatingTextStrRefOnCreature(112006,oPC,FALSE);
+                 SetLocalInt(oPC,"X3_REST_CANCEL_MESSAGE_SENT",TRUE); // sentinel
+                 // value to prevent message played a 2nd time on canceled rest
+             } // play cancel message
+             AssignCommand(oPC,ClearAllActions(TRUE));
+             return;
+         } // cannot mount
+     } // make sure not mounted
+ 
+     if (!GetLocalInt(GetModule(),"X3_MOUNT_NO_REST_DESPAWN"))
+     { // if there is a paladin mount despawn it
+         oMount=HorseGetPaladinMount(oPC);
+         if (!GetIsObjectValid(oMount)) oMount=GetLocalObject(oPC,"oX3PaladinMount");
+         if (GetIsObjectValid(oMount))
+         { // paladin mount exists
+             if (oMount==oPC||!GetIsObjectValid(GetMaster(oMount))) AssignCommand(oPC,HorseUnsummonPaladinMount());
+             else { AssignCommand(GetMaster(oMount),HorseUnsummonPaladinMount()); }
+         } // paladin mount exists
+     } // if there is a paladin mount despawn it
  
      if (GetModuleSwitchValue(MODULE_SWITCH_USE_XP2_RESTSYSTEM) == TRUE)
      {
          /*  Georg, August 11, 2003
              Added this code to allow the designer to specify a variable on the module
              Instead of using a OnAreaEnter script. Nice new toolset feature!
              Basically, the first time a player rests, the area is scanned for the
              encounter table string and will set it up.
          */
          object oArea = GetArea (oPC);
  
*** x2_mod_def_unequ.nss	Mon Aug 04 20:21:29 2008 *** not in prc ***
--- x2_mod_def_unequ.nss	Mon Aug 04 20:18:15 2008
***************
*** 2,40 ****
--- 2,56 ----
  //:: Example XP2 OnItemEquipped
  //:: x2_mod_def_unequ
  //:: (c) 2003 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Put into: OnUnEquip Event
  */
  //:://////////////////////////////////////////////
  //:: Created By: Georg Zoeller
  //:: Created On: 2003-07-16
  //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified On: April 15th, 2008
+ //:: Added Support for Mounted Archery Feat penalties
+ //:://////////////////////////////////////////////
+ 
  #include "x2_inc_switches"
  #include "x2_inc_intweapon"
+ #include "x3_inc_horse"
+ 
  void main()
  {
       object oItem = GetPCItemLastUnequipped();
       object oPC   = GetPCItemLastUnequippedBy();
  
      // -------------------------------------------------------------------------
      //  Intelligent Weapon System
      // -------------------------------------------------------------------------
      if (IPGetIsIntelligentWeapon(oItem))
      {
              IWSetIntelligentWeaponEquipped(oPC,OBJECT_INVALID);
              IWPlayRandomUnequipComment(oPC,oItem);
      }
  
      // -------------------------------------------------------------------------
+     // Mounted benefits control
+     // -------------------------------------------------------------------------
+     if (GetWeaponRanged(oItem))
+     {
+         DeleteLocalInt(oPC,"bX3_M_ARCHERY");
+         HORSE_SupportAdjustMountedArcheryPenalty(oPC);
+     }
+ 
+     // -------------------------------------------------------------------------
      // Generic Item Script Execution Code
      // If MODULE_SWITCH_EXECUTE_TAGBASED_SCRIPTS is set to TRUE on the module,
      // it will execute a script that has the same name as the item's tag
      // inside this script you can manage scripts for all events by checking against
      // GetUserDefinedItemEventNumber(). See x2_it_example.nss
      // -------------------------------------------------------------------------
      if (GetModuleSwitchValue(MODULE_SWITCH_ENABLE_TAGBASED_SCRIPTS) == TRUE)
      {
          SetUserDefinedItemEventNumber(X2_ITEM_EVENT_UNEQUIP);
          int nRet =   ExecuteScriptAndReturnInt(GetUserDefinedItemEventScriptName(oItem),OBJECT_SELF);
          if (nRet == X2_EXECUTE_SCRIPT_END)
*** x2_s2_cursesong.nss	Mon Aug 04 20:22:30 2008 *** modified prc script ***
--- x2_s2_cursesong.nss	Mon Aug 04 20:18:15 2008
***************
*** 245,267 ****
      else if(nPerform >= 21 && nLevel >= 14)
      {
          nAttack = 2;
          nDamage = 3;
          nWill = 1;
          nFort = 1;
          nReflex = 1;
          nHP = 16;
          nAC = 3;
          nSkill = 2;
      }
!     else if(nPerform >= 18 && nLevel >= 12)
      {
          nAttack = 2;
          nDamage = 2;
          nWill = 1;
          nFort = 1;
          nReflex = 1;
          nHP = 8;
          nAC = 2;
          nSkill = 2;
      }
      else if(nPerform >= 15 && nLevel >= 8)
--- 245,267 ----
      else if(nPerform >= 21 && nLevel >= 14)
      {
          nAttack = 2;
          nDamage = 3;
          nWill = 1;
          nFort = 1;
          nReflex = 1;
          nHP = 16;
          nAC = 3;
          nSkill = 2;
      }
!     else if(nPerform >= 18 && nLevel >= 11)
      {
          nAttack = 2;
          nDamage = 2;
          nWill = 1;
          nFort = 1;
          nReflex = 1;
          nHP = 8;
          nAC = 2;
          nSkill = 2;
      }
      else if(nPerform >= 15 && nLevel >= 8)
***************
*** 371,393 ****
  
      if(!GetHasFeatEffect(871, oTarget)&& !GetHasSpellEffect(GetSpellId(),oTarget))
      {
          ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eDur2, OBJECT_SELF, RoundsToSeconds(nDuration));
      }
      float fDelay;
      while(GetIsObjectValid(oTarget))
      {
          if(spellsIsTarget(oTarget, SPELL_TARGET_SELECTIVEHOSTILE, OBJECT_SELF))
          {
               // * GZ Oct 2003: If we are deaf, we do not have negative effects from curse song
!             if (!GetHasEffect(EFFECT_TYPE_DEAF,oTarget))
              {
                  if(!GetHasFeatEffect(871, oTarget)&& !GetHasSpellEffect(GetSpellId(),oTarget))
                  {
                      if (nHP > 0)
                      {
                          ApplyEffectToObject(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_SONIC), oTarget);
                          DelayCommand(0.01, ApplyEffectToObject(DURATION_TYPE_INSTANT, eHP, oTarget));
                      }
  
                      if (!GetIsDead(oTarget))
                      {
--- 371,393 ----
  
      if(!GetHasFeatEffect(871, oTarget)&& !GetHasSpellEffect(GetSpellId(),oTarget))
      {
          ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eDur2, OBJECT_SELF, RoundsToSeconds(nDuration));
      }
      float fDelay;
      while(GetIsObjectValid(oTarget))
      {
          if(spellsIsTarget(oTarget, SPELL_TARGET_SELECTIVEHOSTILE, OBJECT_SELF))
          {
               // * GZ Oct 2003: If we are deaf, we do not have negative effects from curse song
!             if (!GetHasEffect(EFFECT_TYPE_SILENCE,oTarget) && !GetHasEffect(EFFECT_TYPE_DEAF,oTarget))
              {
                  if(!GetHasFeatEffect(871, oTarget)&& !GetHasSpellEffect(GetSpellId(),oTarget))
                  {
                      if (nHP > 0)
                      {
                          ApplyEffectToObject(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_SONIC), oTarget);
                          DelayCommand(0.01, ApplyEffectToObject(DURATION_TYPE_INSTANT, eHP, oTarget));
                      }
  
                      if (!GetIsDead(oTarget))
                      {
*** x2_s2_dyearmor.nss	Mon Aug 04 20:22:30 2008 *** not in prc ***
--- x2_s2_dyearmor.nss	Mon Aug 04 20:18:15 2008
***************
*** 128,150 ****
  
  
  
  
    // GZ@2006/03/26: Added new color palette support. Note: Will only work
    //                if craig updates the in engine functions as well.
    int nColor     =  0;
  
    // See if we find a valid int between 0 and 127 in the last three letters
    // of the tag, use it as color
    int nTest      =  StringToInt(GetStringRight(GetTag(oItem),3));
!   if (nTest > 0 && nTest < DYE_MAX_COLOR_INDEX )
    {
          nColor = nTest;
    }
    else //otherwise, use last two letters, as per legacy HotU
    {
  
          nColor = StringToInt(GetStringRight(GetTag(oItem),2));
    }
  
  
    // move the item into the IP work container
--- 128,150 ----
  
  
  
  
    // GZ@2006/03/26: Added new color palette support. Note: Will only work
    //                if craig updates the in engine functions as well.
    int nColor     =  0;
  
    // See if we find a valid int between 0 and 127 in the last three letters
    // of the tag, use it as color
    int nTest      =  StringToInt(GetStringRight(GetTag(oItem),3));
!   if (nTest > 0 && nTest <= DYE_MAX_COLOR_INDEX )
    {
          nColor = nTest;
    }
    else //otherwise, use last two letters, as per legacy HotU
    {
  
          nColor = StringToInt(GetStringRight(GetTag(oItem),2));
    }
  
  
    // move the item into the IP work container
*** x2_s2_gwildshp.nss	Mon Aug 04 20:22:30 2008 ***not in prc***
--- x2_s2_gwildshp.nss	Mon Aug 04 20:18:15 2008
***************
*** 8,45 ****
--- 8,70 ----
      forms, gaining special abilities
  
      Credits must be given to mr_bumpkin from the NWN
      community who had the idea of merging item properties
      from weapon and armor to the creatures new forms.
  
  */
  //:://////////////////////////////////////////////
  //:: Created By: Georg Zoeller
  //:: Created On: 2003-07-02
  //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified Date: January 26th, 2008
+ //:://////////////////////////////////////////////
+ /*
+     Modified to insure no shapeshifting spells are castable upon
+     mounted targets.  This prevents problems that can occur due
+     to dismounting after shape shifting, or other issues that can
+     occur due to preserved appearances getting out of synch.
+ 
+     This can additional check can be disabled by setting the variable
+     X3_NO_SHAPESHIFT_SPELL_CHECK to 1 on the module object.  If this
+     variable is set then this script will function as it did prior to
+     this modification.
+ 
+ */
  
  #include "x2_inc_itemprop"
  #include "x2_inc_shifter"
+ #include "x3_inc_horse"
  
  
  void main()
  {
      //--------------------------------------------------------------------------
      // Declare major variables
      //--------------------------------------------------------------------------
      int    nSpell = GetSpellId();
      object oTarget = GetSpellTargetObject();
      effect eVis = EffectVisualEffect(VFX_IMP_POLYMORPH);
      int    nShifter = GetLevelByClass(CLASS_TYPE_SHIFTER);
      effect ePoly;
      int    nPoly;
+ 
+     if (!GetLocalInt(GetModule(),"X3_NO_SHAPESHIFT_SPELL_CHECK"))
+     { // check to see if abort due to being mounted
+         if (HorseGetIsMounted(oTarget))
+         { // abort
+             if (GetIsPC(oTarget)) FloatingTextStrRefOnCreature(111982,oTarget,FALSE);
+             return;
+         } // abort
+     } // check to see if abort due to being mounted
  
      // Feb 13, 2004, Jon: Added scripting to take care of case where it's an NPC
      // using one of the feats. It will randomly pick one of the shapes associated
      // with the feat.
      switch(nSpell)
      {
          // Greater Wildshape I
          case 646: nSpell = Random(5)+658; break;
          // Greater Wildshape II
          case 675: switch(Random(3))
                    {
*** x2_s2_wildshape.nss	Mon Aug 04 20:21:33 2008 *** modified prc script ***
--- x2_s2_wildshape.nss	Mon Aug 04 20:18:15 2008
***************
*** 3,33 ****
--- 3,59 ----
  //:: NW_S2_WildShape
  //:: Copyright (c) 2001 Bioware Corp.
  //:://////////////////////////////////////////////
  /*
      Allows the Druid to change into a Red Dragon.
  */
  //:://////////////////////////////////////////////
  //:: Created By: Preston Watamaniuk
  //:: Created On: Jan 22, 2002
  //:://////////////////////////////////////////////
  //:: Last Updated By: Andrew Nobbs May 20, 2003
+ //:://////////////////////////////////////////////
+ //:: Modified By: Deva Winblood
+ //:: Modified Date: January 15th-16th, 2008
+ //:://////////////////////////////////////////////
+ /*
+     Modified to insure no shapeshifting spells are castable upon
+     mounted targets.  This prevents problems that can occur due
+     to dismounting after shape shifting, or other issues that can
+     occur due to preserved appearances getting out of synch.
+ 
+     This can additional check can be disabled by setting the variable
+     X3_NO_SHAPESHIFT_SPELL_CHECK to 1 on the module object.  If this
+     variable is set then this script will function as it did prior to
+     this modification.
+ 
+ */
+ 
+ #include "x3_inc_horse"
  
  void main()
  {
      //Declare major variables
      object oTarget = GetSpellTargetObject();
      effect eVis = EffectVisualEffect(VFX_IMP_POLYMORPH);
      effect ePoly;
      int nMetaMagic = GetMetaMagicFeat();
      int nDuration = GetLevelByClass(CLASS_TYPE_DRUID);
+     if (!GetLocalInt(GetModule(),"X3_NO_SHAPESHIFT_SPELL_CHECK"))
+     { // check to see if abort due to being mounted
+         if (HorseGetIsMounted(oTarget))
+         { // abort
+             if (GetIsPC(oTarget)) FloatingTextStrRefOnCreature(111982,oTarget,FALSE);
+             return;
+         } // abort
+     } // check to see if abort due to being mounted
      //Enter Metamagic conditions
      if (nMetaMagic == METAMAGIC_EXTEND)
      {
          nDuration = nDuration *2; //Duration is +100%
      }
  
      ePoly = EffectPolymorph(POLYMORPH_TYPE_RED_DRAGON);
      //Fire cast spell at event for the specified target
      SignalEvent(oTarget, EventSpellCastAt(OBJECT_SELF, SPELLABILITY_WILD_SHAPE, FALSE));
  
      //Apply the VFX impact and effects
